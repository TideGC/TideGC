我在 xxx 功能中要给另一个模块发送消息，通知它那边我这边已经完成了 xxx 功能，它那边在收到我的消息之后要执行它自己的业务逻辑。

发送消息我们使用的是 RabbitMQ ，当然，不管使用那种消息队列，都需要考虑消息 100% 可达的问题，也就是所谓的实现消息的可靠性。

在这里需要处理和实现的功能有 2 个："确保消息的接收者一定会收到消息" 和 "确保消息的接收者一定只收到一条消息" 。

为了确保消息的可靠性我们先后写了两个版本<small>（ 第二个版本是第一个版本的改进版 ）</small>。无论哪个版本都是基于 RabbitMQ 的发送者确认机制。

## 方案一（自己发）

示例：[reliable-message-sample](https://github.com/hemiao3000/reliable-message-samples.git) 中的 sample-1-slef

因为 RabbitMQ 默认没有开启发送者确认机制，所以我们需要在配置文件中通过修改配置启用它。RabbtiMQ 的发送者确认机制支持 2 个回调：一个是在消息 "走到" 了 RabbitMQ 交换机时触发的回调，另一个是消息 "走到" RabbitMQ 队列时触发的回调。

我们使用的是 RabbitMQ 交换机的回调，因为我们认为发消息的时候消息能 "走到" RabbitMQ 就说明 RabbitMQ 收到了消息，就已经说明消息发送成功了。如果代码没有 bug 的话，消息肯定是能从交换机路由到队列的。所以，我们就没有再使用 RabbitMQ 队列的那个回调了。

为了配合发送者确认机制的使用，我们在发送消息的微服务这边会多创建一个消息表，里面的字段主要有 exchange_name、routing_key、消息内容、消息发送次数和消息状态。创建这个表的目的是我们发送消息的时候实际上不再是直接发送，而是将要发送的消息存到消息表中，然后再靠一个定时任务来发送消息。

我们的发送消息的这个微服务中会有一个专门的定时任务，周期性地从消息表中查询 "发送中" 状态且发送次数还没有减为一的消息进行发送。

结合之前我提到的发送者确认机制中的回调方法，无论消息能不能走到交换机，那个回调方法都会被触发执行，在回调方法中我们会发消息的发送次数减一。在回调方法中，我们可以通过回调方法中的 boolean 参数 ack 的值来确认消息是否"走"到了交换机：

- 如果 ack 的值是 true ，我接下来会把消息表中这个消息的状态改成 "已发送"；
- 如果 ack 的值是 false，那我什么都不做。<small>（ 实际上前面我把这个消息发送次数减一了 ）</small>。

其实整体的逻辑还是挺简单的：就是说如果消息的发送次数还没有耗完，那就让定时任务一直发，要么就是消息能"走到"交换机，要么发送次数耗完了，这样才不再发送了。

---

在消息的接收者这边，因为要做消息的去重，所以，我们项目会要求所有的消息的接收者微服务都要去减一张消息去重表：去重表主要就是消息的 ID 和消息的加入时间。

为了去重，我们这里还需要消息发送方那边做点"配合"工作，就是发送<small>（ 定时任务 ）</small>消息的时候要把消息在消息表中的那个唯一 ID 拼在消息内容的前面，作为消息内容的一部分发过来。

这样，我接收方这边收到消息之后从内容的前面能 "切出" 消息的 ID ，然后把这个 ID 存到消息去重表中进行去重，因为消息去重表中的 ID 列会被我记上唯一索引，所以，一旦是重复 ID 就会报 insert SQL 语句执行失败的错误，自然这就意味着是重复消息了。

请求发送方的"配合"工作除了要在要发送 ID 之外，还有一个"配合"工作是消息的发送者这边要提前准备好、暴露出一个 URI 出来，准备给消息的接收者发起 OpenFeign 的调用。

所以，消息的接收者收到消息后，判断它是否是重复消息，如果不是重复消息，接下来就执行业务逻辑代码，业务逻辑代码执行结束之后，就通过 OpenFeign 调用消息发送者暴露出来的 URI 修改消息的状态，从 "发送中" 改成 "已接收" 。

我们这里的一系列操作之所以能保证消息的可靠性在于，在消息的接收者通过 OpenFeign 来改变消息的状态之前<small>（改成"已接收"）</small>，发消息这边的项目的定时任务是周期性地、不停地在发送的，直到发送次数耗完。

所以，未来进行人工干预的时候，网关就从消息表中查找 `状态 != 已接收` 且 `重发次数=0` 的消息，这些消息就是没"跑通"的消息。

如狗再细分一点的话：

- `状态 == 发送中` 且 `重送次数=0` ，说明是发送过程有问题，RabbitMQ 没有收到消息。
- `状态 == 已发送` 且 `重发次数=0`，说明是接收过程有问题，是消费者没有收到消息，或者是收到消息之后执行业务逻辑失败，导致最终没有改消息状态。

## 方案二（独立的可靠消息服务）

示例：[reliable-message-sample](https://github.com/hemiao3000/reliable-message-samples.git) 中的 sample-2-service

基于方案一的版本，我们改造出方案二。因为方案一有一个很明显的"很麻烦"的地方：如果项目中各个微服务之间都要互相发送消息的话，那么每个微服务都要去创建同样的表（message）表、编写同样的代码<small>（定时任务发消息）</small>。所有我们把"同样"的内容抽取了出来，编写成了一个独立的、专门用来发消息的微服务：可靠消息服务。

对于需要确认对方必须收到的消息，即，100% 可达的消息，各个微服务不再自己发送，而是通过 OpenFeign 将消息内容及"送往的目的地"传给可靠消息服务，由可靠消息服务<small>（的定时任务）</small>来发送。

流程图参见下图：

![rabbitmq-transaction-03](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220627172445.png)

这样做最大的好处在于，消息表就"集中"到了可靠消息服务这里。其它各个微服务就不再需要创建消息表了。

