# 各种锁的概念

## 1. 悲观锁和乐观锁

『**悲观锁**』和『**乐观锁**』并不是某个具体的 `锁` 而是一种并发编程的基本『概念』。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包所引入。

| # | 说明 |
| :- | :- |
| 悲观锁 | 悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。|
| 乐观锁 | 乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。|

## 2. 公平锁和非公平锁

根据线程获取锁的抢占机制，锁又可以分为『**公平锁**』和『**非公平锁**』。

| # | 说明 |
| :- | :- |
| 公平锁 | 公平锁是指多个线程按照申请锁的顺序来获取锁。 |
| 非公平锁 | 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。  |

ReentrantLock 提供了公平锁和非公平锁的实现。

```java
// 公平锁
Lock lock = new ReentrantLock(true);

// 非公平锁
Lock lock = new ReentrantLock(); // 或
Lock lock = new ReentrantLock(false);
```

## 3. 独占锁和共享锁

根据锁能否被多个线程持有，可以把锁分为『**独占锁**』和『**共享锁**』。

| # | 说明 |
| :- | :- |
| 独占锁 | 独占锁是指任何时候都只有一个线程能执行资源操作。|
| 共享锁 | 共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。| 

> Java 中 Lock 是一个接口。

Java 中的 **ReentrantReadWriteLock** 就是共享锁的实现方式，它允许一个线程进行写操作，允许多个线程读操作。

ReentrantReadWriteLock 共享锁演示代码如下：

```java
public static void main(String[] args) throws InterruptedException {

    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    // 读线程
    new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + ": 写线程持有锁");
        lock.writeLock().lock();
        try {
            TimeUnit.SECONDS.sleep(30);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + ": 写线程释放锁");
        lock.writeLock().unlock();
    }).start();

    // 读线程
    new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + ": 读线程持有锁");
        lock.readLock().lock();
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + ": 读线程释放锁");
        lock.readLock().unlock();
    }).start();

    // 重复多个读线程
    // new Thread(...).start();
    // new Thread(...).start();

    // 挂起主线程
    Scanner scanner = new Scanner(System.in);
    scanner.next();
}
```    

以上程序执行结果如下：

```
Thread-2: 写线程持有锁
Thread-3: 读线程持有锁
Thread-4: 读线程持有锁
Thread-5: 读线程持有锁
Thread-2: 写线程释放锁
Thread-3: 读线程释放锁
Thread-5: 读线程释放锁
Thread-4: 读线程释放锁
```

## 4. 可重入锁

『**可重入锁**』指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。我们常用的锁都是可重入锁。

```java
Lock lock = new ReentrantLock();

lock.lock();
lock.lock();
lock.lock();

lock.unlock();
lock.unlock();
lock.unlock();
```

## 5. 自旋锁

『**自旋锁**』是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU 。

在 Java 中，自旋锁是通过 CAS（Compare and Swap）实现的。

-   简单实现

    ```java
    AtomicInteger cas = new AtomicInteger(0);

    new Thread(() -> {
        // 上锁逻辑
        while (!cas.compareAndSet(0, 1))
            ;
        System.out.println(Thread.currentThread().getName() + ": 获得锁");
        TimeUnitSecondsQuietlySleep(5);
        System.out.println(Thread.currentThread().getName() + ": 释放锁");

        // 解锁逻辑
        cas.compareAndSet(1, 0);
    }).start();

    new Thread(() -> {
        // 上锁逻辑
        while (!cas.compareAndSet(0, 1))
            ;
        System.out.println(Thread.currentThread().getName() + ": 获得锁");
        TimeUnitSecondsQuietlySleep(5);
        System.out.println(Thread.currentThread().getName() + ": 释放锁");
        // 解锁逻辑
        cas.compareAndSet(1, 0);
    }).start();

    Scanner scanner = new Scanner(System.in);
    scanner.next();
    ```

-   优化：自定义 SpinLock 类

    ```java
    public class SpinLock {

        private AtomicReference<Thread> cas = new AtomicReference<Thread>();

        public void lock() {
            Thread current = Thread.currentThread();
            // 利用 CAS
            while (!cas.compareAndSet(null, current))
                ;
        }

        public void unlock() {
            Thread current = Thread.currentThread();
            cas.compareAndSet(current, null);
        }

    }
    ```
