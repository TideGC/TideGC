---
alias: 泛型和类型擦除
tag: 泛型 反射
---

# 泛型和类型擦除

**Type** 是 Java 语言中所有类型的公共父接口。<small>这就是最官方的解释。</small>

Class 就是 Type 的一个直接实现类。Type 和 Class，以及 Type 的其它子接口<small>（ 和实现类 ）</small>组成了 Java 的类型体系。

## 先有子（Class），后有父（Type）

在早期的 Java <small>（ 5.0 之前 ）</small>中所有的类型都有一个 Class 对象，包括基本类型和自定义类型：

```java
Student.class
Teacher.class
 String.class
Integer.class
 Double.class
Boolean.class
    int.class int[].class
 double.class double[].class
boolean.class boolean[].class
...
```

Class 对象中包含了当前类型的定义信息，它是 Java 反射的基础。通过一个类型的 Class 对象，你可以查询得到这个类型有哪些域，哪些方法，哪些构造函数等信息。

在这个时候，一个类的 Class 对象中"包含"了足够多的关于这个类的相关信息。

例如对于下面的类：

```java
public class T1 {  
    public int f1;  
    public int[] f2;
}
```

你是使用反射方法能获得 f1 和 f2 两个属性的相关信息：

```java
T1 x = new T1();  
System.out.println(x.getClass().getField("f1"));  
System.out.println(x.getClass().getField("f2"));
```

但是泛型的概念出现后，情况就变复杂了，对于涉及到泛型的数据类型，原本的一些方法<small>（ 1.5 之前出现的方法 ）</small>，所返回的信息中无法"囊括"泛型相关信息。

例如，如果我们上例中的 T1 类变成了一个泛型类：

```java
public class T1<E> {  
    public int f1;  
    public int[] f2;  
	public E[] f3;  
	public Object[] f4;
}
```

仍然使用老办法（）


## 1. Type 体系的历史 

> [!info] 提示
> 实际上，是先后 Class，而后有 Type 。也就是说，一开始并没有 Java 类型 **体系** 这样的概念。
> 
> 是因为引入了泛型概念之后，为了将泛型概念引入 Java，并作出向后兼容，从而为 Class「**补**」了一个 Type 祖先和其它「兄弟」， 从而完善了整个体系。

在早期的 Java <small>（ 5.0 之前 ）</small>中所有的类型都有一个 Class 对象，包括基本类型和自定义类型：

```java
Student.class
Teacher.class
String.class
Integer.class
Double.class
Boolean.class
int.class
int[].class
double.class
double[].class
boolean.class
boolean[].class
...
```

Class 对象中包含了当前类型的定义信息，它是 Java 反射的基础。通过一个类型的 Class 对象，你可以查询得到这个类型有哪些域，哪些方法，哪些构造函数等信息。

但是，在 JDK 5.0 引入泛型概念之后，Java 官方发现，新引入的泛型相关的一些类型，它们**不适用**上面我们所说的『**所有的类型都有一个 Class 对象**』这句话。

这些泛型相关的类型的「**那个对象**」，不能归类于是 Class 对象这个概念之下。它们的「**那个对象**」既和 Class 对象有相似的地方，又和 Class 对象有所区别。

对此，Java 官方抽取了它们和 Class 的相同点，提炼出 Type 概念，并补全了其它的类型：

```txt
Type
├── Class
├── ParameterizedType
├── TypeVariable
├── WildcardType
└── GenericArrayType
```

Type 和它的子接口、实现类<small>（ Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType ）</small>共同组成了 Java 的类型体系。


## 2. 各种 Type 

以 HashMap 的类的定义为例：

```java
public class HashMap<K, V> ... {
    ...
}
```

在这里出现了两种 Class 之外的 Type：

- **\<K, V\>** 中的起到占位符作用的 K 和 V 的类型就是 **TypeVariable** ；

在声明这个类型的变量时，就需要为 K、V 等占位符填上具体的类型，形成类似 `Map<String, Long> map1;` 的语句。其中 map1 的类型就是 `Map<String, Long>` ，那这个类型是类吗？不是，它是一个组合的类型：

- Map 是它的原始类型 RawType ；
- \<String, Long\> 是它的实际参数 ActualTypeArguments ；
- 这个组合类型有一个学名叫做 ParameterizedType ；
- 对于组合类型 Map.Entry\<Long,Short\> 还有一个 OwnerType ，就是 Map 。

我们再以一个自定义的泛型类为例：

```java
public class StringLinkedList<T> extends LinkedList<String> {
    private T[] array;
    ...
}
```

这里的私有属性 *array* 的类型 **T[]** 的类型就是 **GenericArrayType** 。

**WildcardType** 类型其实大家很早就见到过：`Class<?>` 中的这个 `?` 的类型就是 **WildcardType** 。

当然，更复杂一点的泛型通配符可能会是这样：`<? extends Number, ? extends Runnable>` 。

### 工具方法

为了更方便地检测 Type 的具体类型，我们可以准备一个如下的简单的方法：

```java
private static String getTypeName(Type type) {
    if (type instanceof Class)
        return "Class";             // just like String
    else if (type instanceof TypeVariable)
        return "TypeVariable";      // just like T
    else if (type instanceof ParameterizedType)
        return "ParameterizedType"; // just like List<String>";
    else if (type instanceof GenericArrayType)
        return "GenericArrayType";  // just like T[]";
    else
        return "something wrong";   // 理论上不该如此
}
```

### 新类型的新方法

#### ParameterizedType 的 getActualTypeArguments

Class 的 getGenericSuperclass 方法返回的是泛型父类，它的类型是 Type 。

实际上通过 instanceof 运算符，我们可以判断出泛型父类的实际信息是 ParameterizedType 类型。

而 ParameterizedType 类型有一个 getActualTypeArguments 方法，它能返回泛型父类的所使用的泛型参数。

```java
ParameterizedType superclass = (ParameterizedType) StringLinkedList.class.getGenericSuperclass();
for (Type cur : superclass.getActualTypeArguments()) {
    System.out.println(cur);    // 这个例子中只有一个：String
}
```


## 3. 泛型相关新方法

### Method 的 getGenericParameterTypes 方法

> getGenericParameterTypes 方法是 getParameterTypes 方法的升级版。

Method 的 **getGenericParameterTypes** 方法的作用和上面的 *getParameterTypes* 方法类似，不过由于它是一个「新」方法，因此，它的返回结果中会保留泛型信息。

还是同样的上述方法：

```java
public static <T> void demo(T arg0, T[] arg1, String arg2) {
    ...
}
```

**getGenericParameterTypes** 方法的返回值是 Type 的数组<small>（而不是 Class 数组）</small>。

它的三个元素的分别是

- 第一个参数类型 **T** ，类型为 **TypeVariable** ；
- 第二个参数类型 **T[]**， 类型为 **GenericArrayType** ；
- 第三个参数类型 **String**， 类型为 **Class** 。



### Method 的 getGenericReturnType 方法

> getGenericReturnType 方法是 getReturnType 方法的升级版

对于同样的方法，Method 的 **getGenericReturnType** 方法能识别出返回值类型的泛型信息。

它的返回是 T，其类型为 TypeVariable 。

### Class 的 getGenericSuperclass 方法

Class 的 getGenericSuperclass 功能同 getSuperclass，不过它会保留父类的泛型信息。

```java
StringLinkedList.class.getGenericSuperclass()   // LinkedList<String>
```


