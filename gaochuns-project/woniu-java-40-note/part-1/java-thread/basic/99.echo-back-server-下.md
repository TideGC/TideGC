# echo-back-server（下）

## 服务端的实现（第四版）

第四版服务端的实现是为了解决第三版的一个问题：会反复创建、销毁线程。

这里我们模拟线程池的功能，在项目启动之初提前创建好几个线程，并然他们阻塞等待<small>（ 等待 clientSocket ）</small>，主线程负责接收客户端的连接，生产 clientSocket ，而提前创建好的线程则负责消费 clientSocket ，这里是是一个很典型的生产者消费者模型。


```java
private static int nThread = 2;

// 这里简单粗暴地处理了一下异常
public static void main(String[] args) throws Exception {

    ServerSocket serverSocket = new ServerSocket(9999);

    BlockingQueue<Socket> clientSocketQueue = new ArrayBlockingQueue<>(1);

    for (int i = 0; i < nThread; i++) {
        new Thread(() -> {
            while (true) {
                try {
                    Socket myClientSocket = clientSocketQueue.take();   // 阻塞等待
                    nThread--;
                    System.out.println("有一个客户端发起了连接");
                    InputStream is = myClientSocket.getInputStream();
                    OutputStream os = myClientSocket.getOutputStream();

                    while (true) {
                        try {
                            receiveAndSendBack(is, os);
                        } catch (SocketException e) {
                            break;
                        }
                    }

                    os.close();
                    is.close();
                    myClientSocket.close();
                    nThread++;

                    System.out.println("客户端断开了连接");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }).start();
    }

    while (true) {
        // 等待客户端的连接
        Socket clientSocket = serverSocket.accept();

        if (nThread == 0) {
            clientSocket.getOutputStream().close();
            clientSocket.close();
        } else {
            clientSocketQueue.add(clientSocket);
        }
    }
}

private static void receiveAndSendBack(InputStream is, OutputStream os) throws IOException {
    // 略
}
```

## x

使用 JDK 线程池

```java
    public static void main(String[] args) throws Exception {

        Executors.newFixedThreadPool(1);

        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 2,
                0L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>());

        ServerSocket serverSocket = new ServerSocket(9999);

        while (true) {
            // 等待客户端的连接
            Socket clientSocket = serverSocket.accept();

            System.out.println("debug: " + threadPool.getActiveCount());

            try {
                threadPool.execute(new Task(clientSocket));
            } catch (RejectedExecutionException e) {
                closeOutputStreamQuietly(clientSocket);
                closeQuietly(clientSocket);
            }
        }
    }

    public static class Task implements Runnable {
        private final Socket socket;

        public Task(Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            System.out.println("有一个客户端发起了连接");
            InputStream is = SocketUtils.getInputStreamQuietly(socket);
            OutputStream os = SocketUtils.getOutputStreamQuietly(socket);

            while (true) {
                try {
                    SocketUtils.receiveAndSendBack(is, os);
                } catch (RuntimeException e) {
                    break;
                }
            }

            closeOutputStreamQuietly(socket);
            closeInputStreamQuietly(socket);
            closeQuietly(socket);

            System.out.println("客户端断开了连接");
        }
    }

```
