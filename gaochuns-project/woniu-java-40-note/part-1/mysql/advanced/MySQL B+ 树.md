## 数据页（ Page ）

InnoDB 存储引擎中有页<small>（ <em>Page</em> ）</small>的概念，**页是 InnoDB 引擎进行磁盘管理的最小单位**。InnoDB 存储引擎中默认每个页的大小为 16KB ，可通过参数 *innodb_page_size* 将页的大小设置为 4K 、8K 、16K，在 MySQL 中可通过如下命令查看页的大小：

```sql
-- SQL 语句
show variables like 'innodb_page_size';
```

InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，位于同一个页中的数据会被一次性读取出来，而不是需要什么取什么。

在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。


## B 树（ B-Tree ）

B 树是为了磁盘<small>（ 或其它直接存取的辅助存储设备 ）</small>而设计的一种平衡搜索树。B 树类似于红黑树，确切地说是类似于 234 树。

如果你对 红黑树/234树 很熟悉的话，下面的图很容易理解。

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220706071215.png)


在 B 树中，叶子节点中只有数据，而非叶子节点中除了有数据，还有指向其子节点的指针。

模拟查找 *id=29* 的数据的过程：

| # | 操作 | 备注 |
| :-: | :- | :- |
|1| 根据根节点找到磁盘块1，读入内存。| 磁盘 I/O 操作第 1 次  |
|2| 比较 id 发现 29 在区间（17,35），找到磁盘块1的指针P2。  |
|3| 根据 P2 指针找到磁盘块3，读入内存。| 磁盘 I/O 操作第 2 次  |
|4| 比较 id 发现 29 在区间（26,30），找到磁盘块3的指针P2。  | |
|5| 根据 P2 指针找到磁盘块8，读入内存。| 磁盘 I/O 操作第 3 次   |
|6| 在磁盘块8中的关键字列表中找到id=29的数据。| |

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。

> [!note] 提示
> B 树也叫 B- 树，之所以这么叫是为了和 B+ 树中相呼应。

## B+树（ B+Tree ）

B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。

> [!info] 提示
> B 树的中间节点中即存储数据又存储向下的指针，在一个中间节点中，数据“挤占了”指针的空间，进而导致了一个中间节点中记录的向下的指针的数量不多。
> 
> 宏观上看，这就导致了 B 树会变高。变高就意味着如果我们访问的数据在叶子节点上，那么就需要更多的“访问”次数。

B+ 树在 B 树的基础上“激进”了一把：所有的 非叶子节点/中间节点 中只记录 key 和向下的指针，不记录数据内容。这样可以大大加大每个节点存储的“向下的指针”的数量，降低 B+ 树的高度。


B+ 树相对于 B 树有几点不同：

- 非叶子节点只存储键值信息。  
- 所有叶子节点之间都有一个链指针。  
- 数据记录都存放在叶子节点中。

将上一节中的 B 树优化，由于 B+ 树的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+ 树后其结构如下图所示：

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220706070743.png)

> [!tip] 提示
> 上图的横向的、串联其所有 Page 的链表指针是进一步的优化，并非 B+ 树的核心概念。
> 
> 这样优化的目的是为了支持范围查找和分页查询。

## 页的数量

我们可以基于以下的信息进行以下推算和预估计：

- InnoDB 存储引擎中页的大小默认为 16KB ；
- bigint 类型在 InnoDB 存储引擎中占 8 字节大小；
- 指针大小在 InnoDB 存储引擎中占 6 字节大小；
- 以 `id + 指针` 组成的键值对就占 14 字节大小。

假设一张表中的每条数据占 1K 大小，那么，一个磁盘上的 Page 中能记录的数据就有 16 条<small>（ 实际上由于 Page 中还要记录一些其它的数据，所以真实情况下并没有 16 条那么多 ）</small>。

基于上述信息，我们可以进行以下预估。

### 假设 B+ 树的深度为 2

因为 B+ 树的深度为 2 ，那么意味着其它节点都是叶子页。那么，根节点中能记录的 `id+指针` 键值对总共有：`16384 / 14 = 1170` 个。即，最多可以有 `1170` 个 Page 来存储数据。

由于一个 Page 中能记录 16 数据，那么，1170 个页中，总共最多可以有 `1170 x 16 = 18720` 条数据，大约 18 万条<small>（ 不到 19 万条 ）</small>。

也就是说，在 B+ 树深度为 2 的这个前提条件下，这张表中差不多可以有 18 万条数据，

### 假设 B+ 树的深度为 3

如果 B+ 树深度为 3 ，那么也就意味着它有 2 层中间节点。那么，根节点中能记录的中间节点有：`16384 / 14 = 1170` 个。同样，每个根节点中记录的叶子节点又有 `1170` 个，那么深度为 3 的 B+ 树总共会有 `1170 x 1170 = 1368900` 个叶子节点。

由于一个 Page 中能记录 16 条数据，那么 1368900 个页中，总共最多可以有 `1368900 x 16 = 21902400` 条数据，大约 2100 万条<small>（ 不到 2200 万条 ）</small>。

也就是说，在 B+ 树深度为 3 的这个前提条件下，这张表中差不多可以有 2000 万条数据，

### 关于数据库表容量

表面上看起来，2000W 条数据并不少了，但是我们上述的估算是基于表中一条数据只有 1k 大小进行的，而实际情况中一条数据占 1K 大小这个数量级很小。

在 MySQL 可以通过如下命令查询到表的行数据平均长度：

``` sql
-- SQL 语句
SHOW TABLE STATUS LIKE '表名';
```

其中，有一项为 *Avg_row_length* ，它的值就是表的行数据平均长度。

这也是通常所说的，MySQL 单表数据量到千万是个『坎』的原因。因为在百万级情况下，表背后的 B+ 树的深度大概率不会超过 3 层，如果数据量在多，B+ 树的层次会再多加一层，这就意味着查询操作的时间会增加。

因此在数据库中，B+ 树的高度一般都在 2~4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。

如果一张表的数据量多到要突破 4 层了，那么就必须要想办法优化表结构了。

