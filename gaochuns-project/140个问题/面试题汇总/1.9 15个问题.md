### 1.9 15个问题

#### 61. NIO的原理是什么?NIO 有哪些选择器？

```java
原理：

1、NIO是一种基于通道和缓冲区的I/O方式，以块的方式处理数据，采用多路复用的IO模型。

2、Java的NIO主要由三个核心部分组成：Channel、Buffer、Selector。

3、NIO中都从一个Channel开始，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。

4、Buffer（数组）本质上是一块可以读写数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。

5、Selector允许单线程处理多个Channel，如果你的应用打开了多个通道（连接），但每个通道的流量都很低，使用Selector就会很方便。
    
  在Selector中有三个核心类：

Selector：主操作类，通过静态实例化，select()方法来管理已经注册的通道

SelectionKey：注册完通道之后返回的键，通过该类来描述通道的状态

SelectableChannel：通道，通过该类获取Socket对象，将之注册到Selector中

其关系是只用SelectableChannel通道对象才能被Selector.java选择器所复用因为只有SelectableChannel通道对象才有register（Selector sel，int ops）方法
————————————————
版权声明：本文为CSDN博主「Yan1less」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41488523/article/details/88378787
```

原文链接：https://blog.csdn.net/lkm987654321/article/details/123994694

#### 62. 写出单例模式代码，并解决线程安全问题？

线程周期：包含5个阶段，包括：新建、就绪、运行、阻塞、死亡。

步骤：1.构造方法必须私有化，不能在类的外部创建对象

2.在该类的内部创建对象，并私有化

3.提供一个公共的静态方法供外部获取单例对象

划分：懒汉：线程不安全

懒汉模式的优点：弥补了饿汉模式的缺点，起到了 lazy loading 的效果。 * 懒汉模式的缺点：多线程并发时有线程安全问题，有可能创建多个实例。

饿汉：线程安全

饿汉模式的优点

实现简单，而且安全可靠。

```
public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return instance;
    }

}
```

加锁，通过对线程安全问题进行锁的配置，使得在运行的时候不被多个线程访问到。

#### 63. 简述http三次握手？

http的三次握手和四次挥手：

浏览器在给服，务器传输数据之前，有三次握手，握手成功之后，才可以传输数据

1、浏览器需要先发送SYN码，客户端请求和服务器建立连接；

2、服务器接收到SYN码，再发送给客户端SYN+ACK码，我可以建立连接；

3、客户端接收到ACK码，验证这个ACK是否正确，如果正确则客户端和服务端则建立起数据连接；双方的数据发送通道都将开启；



四次挥手：

1、当客户端无数据要传输了，会发送FIN码告诉服务器，我发送完毕了；

2、当服务端接收完毕后，告诉客户端ACK码，告诉客户端你可以把数据通道关闭了；

3、当服务器发送完毕之后，也会发送FIN码，告诉浏览器，数据发送完毕；

4、当客户端接收完毕 之后，同样发送ACK码，告诉服务器，数据接收完毕，你可以关闭；

三次握手和四次挥手的好处：确保数据的安全和完整

#### 64. rabbitmq支持批量操作吗?

量消息是指把消息放到一个集合统一进行提交，这种方案设计思路是希望消息在一个会话里，比如放到 ThreadLocal 里的集合，拥有相同的会话 ID，带有这次提交信息的 size 等属性，最重要的是吧这一批消息进行合并。对于 channel 就是发送一次消息。这种方式也是希望消费端在消费的时候，可以进行批量化的消费，针对一个原子业务的操作进行处理，但是不保证可靠性，需要进行补偿机制。

#### 65. 开发中遇到的异常有哪些？

1.[Java](http://lib.csdn.net/base/javase).alng.NullPointerException 空指针异常

2.java.lang.ClassNotFoundException 指定的类，该路径下不存在

3.java.lang.ArrayIndexOutOfBoundsException 下标越界

4.java.lang.IllegalArgumentException 方法参数错误

5.java.lang.StackOverflowError 堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。

6.java.lang.ArithmeticException 数学运算异常，比如1/0

#### 66. nacos和eureka（jar包）区别?

1.产品区别

Eureka 是Spring Cloud 微服务框架默认的也是推荐的服务注册中心

Nacos是阿里巴巴最新开源的项目，提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。更敏捷和容易地构建、交付和管理微服务平台。



2.心跳区别

Eureka client在默认情况每隔30s想Eureka Server发送一次心跳,当Eureka Server在默认连续90s秒的情况下没有收到心跳, 会把Eureka client 从注册表中剔除,在由Eureka-Server 60秒的清除间隔,把Eureka client 给下线


nacos client 通过心跳上报方式告诉 nacos注册中心健康状态,默认心跳间隔5秒，
 nacos会在超过15秒未收到心跳后将实例设置为不健康状态，可以正常接收到请求
 超过30秒nacos将实例删除,不会再接收请求

自我保护机制

相同点：保护阈值都是个比例，0-1 范围，表示健康的 instance 占全部instance 的比例。

不同点：

1）保护方式不同

Eureka保护方式：当在短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下，Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server.enable-self-preservation: false)

Nacos保护方式：当域名健康实例 (Instance) 占总服务实例(Instance) 的比例小于阈值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例 (Instance) 能正常工作。

2）范围不同

Nacos 的阈值是针对某个具体 Service 的，而不是针对所有服务的。但 Eureka的自我保护阈值是针对所有服务的。

原文链接：https://blog.csdn.net/weixin_43776652/article/details/120874245

#### 67. 什么是uml，实际中有使用过吗？

UML：统一建模语言

作用：用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。

UML并不是一个工业标准，但在Object Management  Group的主持和资助下，UML正在逐渐成为工业标准。OMG之前曾经呼吁业界向其提供有关面向对象的理论及实现的方法，以便制作一个严谨的软件建模语言（Software Modeling Language）。

三个主要模型：

1、功能模型：从用户的角度展示系统的功能，包括用例图。

2、对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。

3、动态模型：展现系统的内部行为。包括序列图，活动图，状态图。

#### 68. 如何解决redis缓存和数据库一致性问题？

setnx，Redisson延时双删，线程池

#### 69. 浏览器常见状态码有哪些？

200，成功

400，参数错误

500,服务器错误

404，请求路径错误

403，权限不足

#### 70. 谈谈你在项目中用到的设计模式？

工厂，单例，代理

单例设计模式

单例设计模式一般有几种实现形式，饿汉式，饱汉式，双重加锁式。

应用：数据库连接池。因为数据库连接池是一种数据库资源，使用数据库连接池的主要是为了节省打开或者关闭数据库连接所造成的效率损耗，这种效率上的损耗还是非常昂贵的，使用单例设计模式可以大大降低这种损耗。

代理模式

1）实际开发中，我使用了单例模式，比如系统要求一个对象只能产生一次，比如设计一个单例类，负责所有数据表的映射处理。

意图（核心）：保证一个类仅有一个实例，并提供一个访问该实例的全局访问点。

主要解决：一个全局使用的类频繁地创建与销毁。

何时使用：当您想控制实例数目，节省系统资源的时候。

如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

关键代码：构造函数是私有的。

常见应用场景：
1）在项目种加载配置文件的类，一般也只是一个对象，没有必要重复加载。

2）项目中的数据库连接池，一般也是单例模式。

3）Spring中的每个bean默认也是单例，优点是方便Spring容器管理。

4）Springmvc中，控制器对象也是单例。

5）在Servlet编程中，每个servlet也是单例。

优点：单例模式只生成一个实例，减少了系统开销。

原文链接：https://blog.csdn.net/weixin_39309402/article/details/104706480



#### 71. linux常用的命令？

pwd 命令 ： 显示用户当前所在的目录

ls [选项][目录或文件]：对于目录，该命令列出该目录下的所有子目录与文件。

cd 目录名：进入指定的目录

find [路径] [选项] 操作：用来在指定目录下查找文件

ps-a：列出所有的进程 

rm -rf+文件、文件夹：删除文件（强删）

#### 72. vue常用的命令有哪些？   

v-for：可用来遍历数组、对象、字符串。

v-mobel：数据双向绑定

v-on：事件绑定

`v-text`是渲染字符串，会覆盖原先的字符串

`v-html`是渲染为html

v-if接受一个条件或布尔值

vue create vue 项目名 创建一个vue项目

#### 73. 谈谈vue的生命周期？

![image-20230109152102955](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230109152102955.png)

1、vue生命周期是什么？

- Vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。

2、vue生命周期的八个阶段

###### 1.beforeCreate：会在实例初始化完成、props 解析之后、data() 和 computed 等选项处理之前立即调用。此时不能获得DOM节点。

###### 2.created：在这个阶段vue实例已经创建，以下内容已经设置完成：响应式数据、计算属性、方法和侦听器。然而，此时挂载阶段还未开始，因此 $el 属性仍不可用。仍然不能获取DOM元素。

###### 3.beforeMount：在组件内容被渲染到页面之前自动执行的函数，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。

###### 4.mounted：在组件被渲染之后自动执行的函数。一般我们的异步请求都写在这里。在这个阶段，数据和DOM都已被渲染出来。

###### 5.beforeUpdate：数据变化的时候自动执行的函数，此时变化后的数据还未渲染到页面之上。.

###### 6.updated： 数据变化之后自动执行的函数，此时变化后的数据已经渲染到页面之上。

###### 7.beforeUnmount： 当 Vue 应用被销毁时，自动执行的函数。

###### 8.unmounted：当 Vue 应用被销毁后，且 dom 完全销毁之后，自动执行的函数。

#### 74. 谈谈Java 中的 ==和equals，以及equals和hashCode 的区别与联系？

1）“==”对于基本数据类型，只要值相等，就返回true，否则返回false。

         若比较的为对象，则判断的是两个对象是否处于同一个内存地址。

（2）equals为Object类中的方法，Object中equals默认使用==来判断，因此一般来讲equals与“==”并无区别，完全相同。

        Object是所有类的父类，在不少类中都对equals进行了重写，比如最常用的String类，因此在String中比较的是值，而非地址。
    
        基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，==是比较地址的
equals()是对两个对象的地址值进行的比较（即比较引用是否相同）。
 　　hashCode()是一个本地方法，它的实现是根据本地机器相关的。



  1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。

​     2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。



原文链接：https://blog.csdn.net/Nacht_one/article/details/114792064

#### 75. springboot配置文件优先级是怎么样？

优先级从大到小如下：
 bootstrap.properties -> bootstrap.yml -> application.properties -> application.yml

#### 76. spring定义单例Bean和多例Bean的场景？

实体类，使用的是多例

controller，service，dao单例

当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。

当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean.

当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例

原文链接：https://blog.csdn.net/weixin_45197447/article/details/105753413