### 1.6 15个面试题

#### 46ThreadPoolExecutor线程池有哪些参数？

1.corePoolSize:线程池中的常驻核心线程数

        1).在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近视理解为今日当值线程
    
        2).当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.

2.maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1

3.keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止

默认情况下:

只有当线程池中的线程数大于corePoolSize时keepAliveTime才会起作用,知道线程中的线程数不大于corepoolSIze,

4.unit:超时的单位

5.workQueue:(阻塞)任务队列,被提交但尚未被执行的任务.

6.threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可

7.handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示 数(maxnumPoolSize)时如何来拒绝.

原文链接：https://blog.csdn.net/jun_422/article/details/121289666

#### 47如何保证一个线程执行完再执行第二个线程？

#### 48.线程池的队列有哪些？拒绝策略有哪些？

三种队列：

1.SynchronousQueue（无缓冲的等待队列，无界）

直接提交策略表示线程池不对任务进行缓存。新进任务直接提交给线程池，当线程池中没有空闲线程时，创建一个新的线程处理此任务。这种策略需要线程池具有无限增长的可能性。

Executors.newCachedThreadPool()使用SynchronousQueue创建线程池。

2.LinkedBlockingQueue（基于链表，无界）

LinkedBlockingQueue将导致当所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。

Executors.newFixedThreadPool(3)使用LinkedBlockingQueue创建线程池。

Executors.newSingleThreadExecutor()使用LinkedBlockingQueue创建线程池。

3.ArrayBlockingQueue（基于数组，有界）

有界队列（如ArrayBlockingQueue）有助于防止资源耗尽当最大线程数有限时，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷。


2.拒绝策略

接口RejectedExecutionHandler提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种拒绝策略。

1.AbortPolicy

拒绝策略：队列存满后丢弃任务，抛出运行时异常RejectedExecutionException。（jdk默认策略）

2.DiscardPolicy

拒绝策略：队列存满后，不能执行的任务将被丢弃。不抛异常

3.DiscardOldestPolicy

拒绝策略：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。

该策略稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。

 

4.CallerRunsPolicy

拒绝策略：如果加入队列失败，由主线程自己执行该任务
————————————————

原文链接：https://blog.csdn.net/u010277958/article/details/108620617

#### 49.线程池的核心线程数一般如何设置?

cpu数量=总任务时长/计算任务时间

线程数：CPU数量*（总任务时长/计算任务时间）

![image-20230106151031983](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230106151031983.png)

CPU密集型：核心线程数=CPU核心数(或 核心线程数=CPU核心数+1)

I/O密集型：核心线程数=2*CPU核心数（或 核心线程数=CPU核心数/（1-阻塞系数））

混合型：核心线程数=（线程等待时间/线程CPU时间+1）*CPU核心数

原文连接: https://baijiahao.baidu.com/s?id=1674443399921340296&wfr=spider&for=pc

#### 50.ThreadLocal 为什么是线程安全的？

ThreadLocal 为每一个线程维护变量的副本,把共享数据的可见范围限制在同一个线程之内,因此 ThreadLocal 是线程安全的,每个线程都有属于自己的变量。

#### 51.ThreadLocal 为什么会发生内存泄漏？如何解决？ 

造成泄漏的原因：

由于ThreadLocal对象是弱引用，如果外部没有强引用指向它，它就会被GC回收，导致Entry的Key为null

如果当前的情况下在栈中将threadlocal1的引用设置为null，强引用1将会失效，那堆中的threadlocal1对象因为ThreadLocalMap的key对它的引用是弱引用，将会在下一次gc被回收，那就会出现key变成null，如果这时value外部也没有强引用指向它，那么value就永远也访问不到了，按理也应该被GC回收，但是由于ThreadLocalMap.Entry对象还在强引用value，导致value无法被回收，这时「内存泄漏」就发生了，value成了一个永远也无法被访问，但是又无法被回收的对象。

解决办法：将ThreadLocal设置为空之前，执行remove（）方法，会将key为空的键值对清空          

————————————————

原文链接：https://blog.csdn.net/oliver486/article/details/123798272

#### 52.多线程中的i++线程安全吗？

不安全。因为i++不是原子性操作。i++分为读取i值，对i值加1，再赋值给i++，

执行过程中任何一步都有可能被其他线程抢占。

#### 53.new ReentrantLock() 创建的是公平锁还是非公平锁？

ReentrantLock通过构造参数fair来判断是创建公平锁还是非公平锁，底层中的独享锁的实现以及队列等待功能依赖于AQS，ReentrantLock是根据传入的参数来决定是否使用公平锁，默认使用非公平锁

```java
// 公平锁
Lock lock = new ReentrantLock(true);

// 非公平锁
Lock lock = new ReentrantLock(); // 或
Lock lock = new ReentrantLock(false);
```



#### 54.为什么非公平锁吞吐量大于公平锁？

吞吐量： 吞吐量是指系统在单位时间内处理请求的数量

比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。

#### 55.如何实现对象的浅拷贝和对象的深拷贝？

浅拷贝：在拷贝一个对象时，复制基本数据类型的成员变量，但对引用数据类型的成员变量只进行引用的传递（复制其地址引用），并不会创建一个新的对象。简单地说就是被拷贝对象和浅拷贝得到的新对象，它们的引用数据类型的成员变量指向同一个内存地址。

深拷贝：在拷贝一个对象时，除了复制基本数据类型的成员变量，对引用数据类型的成员变量进行拷贝时，会创建一个新的对象来保存引用类型的成员变量。
简单地说就是被拷贝对象和深拷贝得到的新对象，它们的引用数据类型的成员变量指向不同的内存地址。
————————————————

java已经内置了 Cloneable 抽象原型接口，自定义的类型只需实现该接口并重写 Object.clone() 方法即可完成本类的浅拷贝。

Cloneable 是一个空接口。Java之所以提供 Cloneable 接口，只是为了在运行时通知Java虚拟机可以安全地在该类上使用 clone() 方法。而如果该类没有实现 Cloneable 接口，则调用 clone() 方法会抛出 CloneNotSupportedException 异常。

一般情况下，如果使用 clone() 方法，则需满足以下条件：
    1、对任何对象 o，都有 o.clone() != o。换言之，克隆对象与原型对象不是同一个对象；
    2、对任何对象 o，都有 o.clone().getClass() == o.getClass()。换言之，复制对象与原对象的类型一样；
    3、如果对象 o 的 equals() 方法定义恰当，则 o.clone().equals(o) 应当成立。

深拷贝可以有以下几种不同的实现方式：
    1、嵌套 clone 方法：在需要克隆的对象以及该对象的引用类型的变量的类中全部实现 cloneable 接口，但是对于层级比较深的对象，不太友好；
    2、使用序列化流：使要序列化的对象和该对象的引用类型成员变量对象的类都实现 Serializable 接口，将对象序列化到输出流中，然后再反序列化为对象就完成了完全的复制操作。但是静态的成员和 transient 关键字修饰的成员不能被序列化；
    3、使用开源工具类，例如，json类库（FastJson，GSON等将对象转化为json字符串，然后将json字符串转换为对象），Spring的BeanUtils，Cglib的BeanCopier。



原文链接：https://blog.csdn.net/qq_41863849/article/details/125739614

#### 56.Stringbuilder和stringbuffer有什么区别？

区别：1.版本不一样，Stringbuilder是jdk1.5引入的，是线程不安全，stringbuffer是jdk1.0引入，是线程安全

2.StringBuffer可变字符串、效率低，StringBuilder可变字符序列、效率高

使用原则：

如果要操作少量的数据，用String ；

单线程操作大量数据，用StringBuilder ；

多线程操作大量数据，用StringBuffer。



#### 57.初始化一个集合，内含100个元素，需要创建10个线程，每个线程读取集合中固定区间的元素，例如第一个线程读集合中前十个元素，写出代码？

#### 58.100个线程同时向一个银行账户中存入1元钱？

```java
public class Account {
    /**
     * 银行账户
     *
     * @author wb
     */
    private double balance;     // 账户余额
    private Lock accountLock = new ReentrantLock();

    /**
     * 存款
     *
     * @param money 存入金额
     */
    public synchronized void deposit(double money) {

        accountLock.lock();

        try {
            double newBalance = balance + money;
            try {
                Thread.sleep(10);   // 模拟此业务需要一段处理时间
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            balance = newBalance;
        } finally {
            accountLock.unlock();
        }

    }

        /**
         * 获得账户余额
         */
        public double getBalance() {
            return balance;
        }
    }







public class AddMoneyThread implements Runnable{
    private Account account;    // 存入账户
    private double money;       // 存入金额

    public AddMoneyThread(Account account, double money) {
        this.account = account;
        this.money = money;
    }

    @Override
    public void run() {
        account.deposit(money);
    }

}
```



#### 59.IO中字节流和字符流有什么区别？常用的流有哪些？

字节流与字符流

在java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类）

区别： 字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串； 2. 字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以



**常用的流**

1. 对文件进行操作：FileInputStream（字节输入流）、FileOutputStream（字节输出流）、FileReader（字符输入流）、FileWriter（字符输出流）
2. 对管道进行操作：PipedInputStream（字节输入流）、PipedOutStream（字节输出流）、PipedReader（字符输入流）、PipedWriter（字符输出流）
3. 字节/字符数组：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter
4. Buffered 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter
5. 字节转化成字符流：InputStreamReader、OutputStreamWriter
6. 数据流：DataInputStream、DataOutputStream
7. 打印流：PrintStream、PrintWriter
8. 对象流：ObjectInputStream、ObjectOutputStream
9. 序列化流：SequenceInputStream

#### 60.BIO和NIO有什么区别？

BIO和NIO的区别

BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多；

BIO是同步阻塞的，NIO是同步非阻塞的

BIO基于字节流和字符流进行操作的，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作的，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件，因此使用单个线程就可以监听多个客户端通道


原文链接：https://blog.csdn.net/weixin_48872249/article/details/113845526