### 1.10 15个问题

#### 77.数组递归求和？

```java
public class Demo2 {

    private int sum = 0;


    /**
     * 递归求和
     * @param num
     */
    public void sum(int num) {
        this.sum += num--;

        if(0 < num){
            sum(num);
        } else {
            System.out.println("sum = " + sum);
        }
    }

    public static void main(String[] args) {
        Demo2 demo2=new Demo2();
        demo2.sum(10);
    }
    
}

```

#### 78. String类型的2个字符串内部是怎么相加的？

 两个以上的字符串常量直接相加，在预编译的时候"+"会被自动优化，
    会自动将多个字符串常量合成一个新的字符串常量

#### 79. nacos集群宕机，服务是否正常使用？

可以，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表

#### 80. nacos配置中心一般都会配置什么内容

项目中yaml中的配置都可以写到配置中心

项目中yaml中可能会被改变的内容写到配置中心

**配置命名空间:**
 命名空间主要用于隔离开发环境

**配置列表**
 在命名空间中配置好后，在配置列表中就会有几个命名空间的tab。

**Data ID:**
 Data ID是配置项的唯一标识，它的命名是有一定规范的

**Group**  组

#### 81. hashcode是怎么算的？

hash码是一个整数，表示调用对象的状态,每个字符的的哈希码值等于它的ascii字符码

hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置 每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode

#### 82. MySQL的innodb引擎为什么使用b+tree索引，而不是B-tree的索引结构？

B+树索引支持精确查询、比较查询、范围查询、[模糊查询](https://www.zhihu.com/search?q=模糊查询&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2666309015})、排序等多种查询方式

(1)B+树空间利用率更高，可减少I/O次数

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。而因为B+树的内部节点只是作为索引使用，而不像B树那样每个节点都需要存储硬盘指针。也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I/O操作。



(2)增删文件(节点)时，效率更高

因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。

(3)B+树的查询效率更加稳定

因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。

原文链接：https://blog.csdn.net/universsky2015/article/details/114121766

#### 83. mysql的联接有哪些？各有什么特点？

左联，以join左边的表为基表，左边的有的数据全部显示，如果没有与基表相关联的数据，则补null（on不能省略）

右联，以join右边的表为基表，右边的有的数据全部显示，如果没有与基表相关联的数据，则补null

内联，取两张表的对应的数据（外键）（会有笛卡尔积的问题，on可以省略）

#### 84. mysql的锁类型有哪些？各有什么特点？

共享锁：（读锁），当一个事务为数据加上锁后，其他事务只能对该数据加读锁，而不是加写锁
    排他锁：（写锁），当一个事务为数据加上锁后，其他的请求不能为该数据加任何的锁
    表锁：锁整个表
    行锁：锁整行数据(insert,update,delete默认使用的就是行锁)
    记录锁：是行锁的一种，只不过记录锁只能锁住表中的某一条数据
    页锁：介于行锁和表锁之间的一种锁，锁定的是与当前操作数据相邻的数据
    间隙锁：是行锁的一种，锁住的是表中数据的一个区间
    临键锁：是行锁的一种，会把查询的记录锁住

锁的介绍：

1.共享锁（share lock）：共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能加写锁，直到所有的读锁释放之后其他事务才能对其加写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据时不支持修改，避免出现重复读的问题。

2.排他锁（exclusive lock）：排他锁又称写锁，简称X锁；当一个事务为数据加上写锁之后，其他请求不能再为数据加任何锁，直到该锁释放后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改的时候，不允许其他人同时修改数据，也不允许其他人读取数据，避免了出现脏数据和脏读的问题。

3.表锁（table lock）：表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表时，必须等前一个事务释放了锁才能对该表进行访问。特点：粒度大，加锁简单，容易冲突。

4.行锁：行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可以正常访问。特点：粒度小，加锁比较麻烦，不容易冲突，相比表锁支持的并发要高。（增，删，改默认就是行锁）

5.记录锁：记录锁也是行锁中的一种，只不过记录锁只能锁住表中的某一条记录，记录锁是说事务在加锁之后数据可以避免在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读物的脏读问题。

6.页锁：页级锁是Mysql中粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多；行级锁冲突少，但速度慢。所以取了折衷的页级锁，一次锁定相邻的一组记录。特点：开销和加锁时间介于表锁和行锁之间，会出现死锁；锁的粒度介于表锁和行锁之间，并发度一般。

7.间隙锁：是属于行锁的一种。间隙锁是在事务加锁后其锁住的是表记录的一个区间，当表的相邻id之间出现空隙则会形成一个区间，遵循左开右闭的原则。范围查询并且查询未命中记录，查询条件必须命中索引，间隙锁只会出现在REPEATABLE_READ（重复读）的事务级别中。

8.临键锁：也属于行锁的一种，并且它是InnoDB的行锁默认算法，总结来说他就是记录锁和间隙锁的组合，临键锁会把查询的记录锁住，同时也会把该范围查询内的所有间隙空间也锁住，再之它会把相邻的下一个区间也锁住。

原文链接：https://blog.csdn.net/qq_27181375/article/details/126469977

#### 85. 行锁什么时候会升级为表锁？

索引失效导致行锁升级为表锁

#### 86. 如何实现行锁？

  通过索引列做为条件查询数据时实现行锁，如果查询条件不是索引列，则自动变为表锁

#### 87. 数据库的三范式有什么特点？

 1NF:每一列都不可分割
    2NF:每一列数据都与主键相关(每一行必须有主键)
    3NF：多张表中不要出现相同的字段

四大特性：原子性，一致性，隔离性，持久性

原文链接：https://blog.csdn.net/qq_38391994/article/details/121010670

#### 88. mysql的隔离级别有哪些？如何解决脏读和不可重复读以及幻读问题？

隔离级别：

读已提交，读未提交，可重复读，串行化

解决：一个事务读到另外一个事务还没有提交的数据，我们称之为脏读。解决方法：把事务隔离级别调整到READ COMMITTED

脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。

一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。解决方法：把事务隔离级别调整到REPEATABLE READ。

不可重复读后果：那么任何时候，查询到的数据，都有可能被其他事务更新，查询的结果将是不确定的。

一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读。解决方法：把事务隔离级别调整到SERIALIZABLE。

幻读，针对的是，Insert操作。

#### 89. mysql的事务特性有哪些？底层是怎么实现的？

四大特性：原子性，一致性，隔离性，持久性

原子性：事务的原子性就是通过undo log日志进行实现的。当事务需要进行回滚时，InnoDB引擎就会调用undo log日志进行SQL语句的撤销，实现数据的回滚

一致性：要求事务操作前后数据一致，但是在操作过程中必然会有短暂的不一致

隔离性：隔离性的实现主要是依靠MVCC+锁来实现。

持久性：通过另外一种日志记录：
redo log又叫重做日志，是InnoDB存储引擎中产生的，记录了对数据库中每个页的修改，redo log分为两部分：一部分是在内存中的缓冲日志 （redo log buffer），一部分是在磁盘上的文件日志 （redo log file），内存是会丢失的，而磁盘是永久的

原文链接：https://blog.csdn.net/Be_insighted/article/details/124610832

#### 90. MVCC解决了什么问题？，底层是如何实现的？

MVCC是一种用来解决读写冲突的无锁并发控制

MVCC能够解决：

　　1.在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作时也不用阻塞读操作，提高了数据库并发读写的性能。

　　2.解决脏读、幻读、不可重复度等事务隔离问题，但是不能解决更新丢失问题。

mvcc底层实现要素:

在这之前需要知道MVCC只在REPEATABLE READ（可重复读） 和 READ COMMITTED（已读提交）这俩种隔离级别下适用。

mvcc实现原理是通过 隐藏字段（创建时版本号、回滚指针、删除版本号）、undo log 、Read view来实现的。

1.隐藏字段

在Innodb存储引擎中，在有聚簇索引的情况下每一行记录中都会隐藏俩个字段，如果没有聚簇索引则还有一个6byte的隐藏主键。

创建版本号：创建记录事务ID

删除版本号：删除/修改记录事务ID。这里只是将字段标记为删除状态。

回滚指针：指向记录上一个版本

2.undo log

undo log 可以实现回滚操作来实现原子性，另外一个作用就是实现多版本控制 MVCC。

undo log细分为两种，insert时产生的undo log、update，delete时产生的undo log

在Innodb中insert产生的undo log在提交事务之后就会被删除，因为新插入的数据没有历史版本，所以无需维护undo log。

update和delete操作产生的undo log都属于一种类型，在事务回滚时需要，而且在快照读时也需要，则需要维护多个版本信息。只有在快照读和事务回滚不涉及该日志时，对应的日志才会被purge线程统一删除。

purge线程会清理undo log的历史版本，同样也会清理del flag标记的记录。

undo log 在mvcc中的作用就是 undo log 保存一个版本链，也就是上面回滚指针字段连接的。

当数据库执行select语句时会产生一致性试图read view。

read view是由查询时所有未提交事务ID组成的数组，数组中最小的事务ID为min_id和已创建的最大事务ID为max_id组成，查询的数据结果需要跟read-view做比较从而得到快照结果。

所以说undo log在mvcc中的作用就是为了根据存储的事务ID和一致性视图做对比，从而得到快照结果。

3.read view

当执行SQL语句查询时会产生一致性视图，也就是read-view，它是由查询的那一时间所有未提交事务ID组成的数组，和已经创建的最大事务ID组成的。

原文链接：https://blog.csdn.net/jinwufeiyang/article/details/119578180

#### 91. mysql中的redo、undo、binlog日志有什么用？

redo 日志，每当有操作执行前，在数据真正更改前，会先把相关操作写入 redo 日志。这样当断电，或者发生一些意外，导致后续任务无法完成时，待系统恢复后，可以继续完成这些更改。

和 redo 日志对应的 undo 日志，也叫撤消日志，记录事务开始前数据的状态，当一些更改在执行一半时，发生意外而无法完成，就可以根据撤消日志恢复到更改之前的状态。

binlog 日志是 MySQL sever 层维护的一种二进制日志（归档日志），是 MySQL 最重要的日志之一，它记录了所有的 DDL 和 DML 语句，除了数据查询语句 select、show 等，还包含语句所执行的消耗时间。

binlog 的主要目的是复制和恢复，用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句，并以事务日志的形式保存在磁盘中。 binlog 主要应用在 MySQL 的主从复制过程中，MySQL集群在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 节点，再从节点回放来达到 master-slave 数据一致的目的。

原文链接：https://blog.csdn.net/daohangtaiqian/article/details/127801558



#### 92. 如何开启慢查询日志？

set global slow_query_log=‘ON’;

#### 93. mysql中的索引是什么？

索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构

话意思是索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

#### 94. 索引有哪些分类？索引结构有哪些？

主要索引类型为：
1，普通索引：普通索引是最基本的索引，它没有任何限制，值可以为空；仅加速查询。
2，唯一索引：唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
3，主键索引：主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
4，组合索引：组合索引指在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。
5，全文索引：全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。

索引结构：

1.哈希表([散列表](https://so.csdn.net/so/search?q=散列表&spm=1001.2101.3001.7020))

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。

2.有序数组

有序数组在范围查询中优势非常明显，可以采用二分法，能大大缩短查询时间，尤其是数据量比较大时。时间复杂度是时间复杂度是 O(log(N))。如果往中间插入一条数据，就需要把后续数组都往后移,这个时候有序数组的成本就很高了.

所以，有序数组索引只适用于静态存储引擎

3.二叉树(N叉树)

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

#### 95. 如何合理创建索引？

 经常当做条件查询的字段
    长度小（内容小）
    尽量覆盖常用的查询字段

#### 96. 如何分析mysql的性能？

1.使用explain命令+select语句

2.开启慢查询日志

首先查看MySQL是否开启慢查询`show variables like 'slow_query_log';`

