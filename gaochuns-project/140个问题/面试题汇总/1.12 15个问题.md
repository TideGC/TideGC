### 1.12 15个问题

#### 113.  Spring中的Bean是线程安全的吗？ 

spring bean默认来说，都是线程不安全的

#### 114.  说一下 Spring 中 Bean 的生命周期？

![image-20230112161051584](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230112161051584.png)

四个阶段：

- 实例化 Instantiation

      第一个，实例化，**实例化就是用来给Bean对象分配内存空间**，以及注意此时的属性是默认值。 

    ​    该步骤对应的Spring源码中的方法名称：**createBeanInstance()**。

      对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个   尚未初始化的依赖时，容器就会调用createBean进行实例化。

    ​    对于ApplicationContext容器，当容器启动之后，便实例化所有的bean。

- 初始化--属性赋值 Populate

    Bean对象的属性赋值分为两个部分： 

    - ​     一个是**用户自定义**的属性的赋值（依赖注入）； 

          **用户自定义**的属性的赋值对应的Spring源码中的方法名称：**populateBean**

         实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行属性 的依赖注入。
             紧接着，Spring根据BeanDefinition中的信息进行依赖注入。
             并且通过BeanWrapper提供的设置属性的接口完成依赖注入。

        

    - ​    一个是对**引用的容器级别对象**的属性的赋值。 

        对**引用的容器级别对象**的属性的赋值对应的Spring源码中的方法名称：**invokeAwareMethods**

           对**引用的容器级别对象**的属性的赋值 --> **检查Aware相关接口并注入xxxAware相关依赖 !**

        ​    对Bean的属性的依赖注入步骤完成之后，紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。

        补充：**什么是Aware接口？**

        ​    Aware接口里面没有任何方法，它是一个空接口，简单来说，Aware接口它就是一个标识，只是具有标识作用，具体实现是由它的那些个子接口去决定的。

- 初始化--增强实现 PostProcessor

- 使用和销毁 Destruction

原文链接：https://blog.csdn.net/qq_44750696/article/details/123469089

#### 115. Spring、SpringBoot、SpringCloud 的区别是什么？

**Spring**:是一个生态体系（也可以说是技术体系），是集大成者，它包含了Spring Framework、Spring Boot、Spring Cloud等，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案;

**SpringBoot**:使用了默认大于配置的理念，集成了快速开发的spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；

**SpringCloud**:大部分的功能插件都是基于springBoot去实现的，springCloud关注于全局的微服务整合和管理，将多个springBoot单体微服务进行整合以及管理； springCloud依赖于springBoot开发，而springBoot可以独立开发；

#### 116. BeanFactory和applicationContext区别

applicationContext是BeanFactory的子接口。

1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题

ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误

2.BeanFactory和ApplicationContext都支持[BeanPostProcessor](https://so.csdn.net/so/search?q=BeanPostProcessor&spm=1001.2101.3001.7020)、BeanFactoryPostProcessor的使用，但两者之间的区别是：**BeanFactory需要手动注册，而ApplicationContext则是自动注册。**

3.beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex  主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。

补充：**因此，在实际开发中，通常都选择使用 ApplicationContext，而只有在系统资源较少时，才考虑使用 BeanFactory。**

#### 117. BeanFactory和FactoryBean的区别是什么？

BeanFactory：是一个工厂，创建IOC容器的工厂

FactoryBean：是一个bean

 1）BeanFactory 是接口，提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，顶层接口。

   2）FactoryBean 也是接口，为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单的工厂模式和装饰模式 ，我们可以在getObject()方法中灵活配置.

 区别：FactoryBean是个Bean.在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 .



原文链接：https://blog.csdn.net/jason_jiahongfei/article/details/106164376

#### 118. redis基本数据类型有哪些？

字符串，哈希，list  set  zset

#### 119. redis支持持久化的方式？各有什么优点？实际上如何选择？

1.RDB(快照)

- **体积更小**：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件。
- **恢复更快**：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。
- **性能更高**：父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。
- rdb的缺点：
    - **故障丢失**：因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。
    - **耐久性差**：相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。

2.AOF（文件追加的方式）

AOF优点：

- **数据保证**：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，也最多丢失一秒数据
- **自动缩小**：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。

AOF缺点：

- **性能相对较差**：它的操作模式决定了它会对redis的性能有所损耗。
- **体积相对更大**：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。
- **恢复速度更慢**：AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF  文件在重新载入时，无法将数据集恢复成保存时的原样。测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集，  并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug  的。

实际选择：看需要性能还是需要一致性

- 混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。
- 策略：推荐主节点关闭RDB，从节点开启RDB，然后都开启AOF，保存策略：everysec

#### 120. redis集群方式有哪些？

主从同步，哨兵，集群

#### 121. springboot整合redis方式？

配置：IP ，端口，储存的序号

方式一：使用Autoconfiguration自动加载。（添加依赖+redis配置）

方式二：xml加载 （添加依赖+redis配置）

#### 122. 消息队列的应用场景有哪些？

异步处理，应用解耦，流量削锋和消息通讯四个场景。

原文链接：https://blog.csdn.net/xmtblog/article/details/98694876

#### 123. 如何保证消息可靠性？

可靠性投递：解决发送成功发送的问题，重试完了之后需要人工干预  消息表

可靠性消费：消息的重复消费问题（特殊情况下，发送方向队列中发送了多条内容相同的消息）  消息去重表

采用事务机制和confirm机制

**事务机制：**

​    RabbitMQ 提供了事务功能，生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。

伪代码：![image-20230112134836691](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230112134836691.png)



**confirm机制（可靠性投递的具体实现，常用）：**

​    RabbitMQ可以开启 confirm 模式，在生产者那里设置开启 confirm 模式之后，生产者每次写的消息都会分配一个唯一的 id，如果消息成功写入 RabbitMQ 中，RabbitMQ 会给生产者回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，生产者可以发送。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发。

注意：RabbitMQ的事务机制是同步的，很耗型能，会降低RabbitMQ的吞吐量。confirm机制是异步的，生成者发送完一个消息之后，不需要等待RabbitMQ的回调，就可以发送下一个消息，当RabbitMQ成功接收到消息之后会自动异步的回调生产者的一个接口返回成功与否的消息。


链接：https://www.jianshu.com/p/b4e2f2d66002

#### 124. 如何保证消费方正确消费消息？

可靠性消费：消息的重复消费问题（特殊情况下，发送方向队列中发送了多条内容相同的消息）  消息去重表

RabbitMQ 中提供了消息消费确认机制。当消费者去消费消息的时候，可以通过指定 autoAck 参数来表示消息消费的确认方式。

当 autoAck 为 false 的时候，此时即使消费者已经收到消息了，RabbitMQ 也不会立马将消息移除，而是等待消费者显式的回复确认信号后，才会将消息打上删除标记，然后再删除。
当 autoAck 为 true 的时候，此时消息消费者就会自动把发送出去的消息设置为确认，然后将消息移除（从内存或者磁盘中），即使这些消息并没有到达消费者。


原文链接：https://blog.csdn.net/u012702547/article/details/120158966

#### 125. 什么情况下消息会进入到死信队列？

1.[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)消息长度达到限制（队列中最多可以存放的消息）；

2.消费者拒接消费消息，并且不重回队列；

3.原队列存在消息过期设置，消息到达超时时间未被消费。

#### 126.rabbitmq的工作模式有哪些？

**Rabbitmq的工作模式有六种：**

1.simple简单模式

一个队列中一条消息，只能被一个消费者消费。

2.work工作模式

一个生产者，多个消费者，每个消费者获取到的消息唯一。

​      publish/subscribe订阅模式

​    一个生产者发送的消息被多个消费者获取。

​      routing路由模式

​      生产者发送的消息主要根据定义的路由规则决定往哪个队列发送。

​      topic 主题模式

​     生产者，一个交换机(topicExchange)，模糊匹配路由规则，多个队列，多个消费者。

​    RPC模式

客户端 Client 先发送消息到消息队列，远程服务端 Server 获取消息，然后再写入另一个消息队列，向原始客户端 Client 响应消息处理结果。

#### 127.char和varchar有什么区别？

1.char类型的长度是固定的，varchar的长度是可变的。

2.char类型的效率比varchar的效率稍高

3.4.varchar比char节省空间，但是在效率上比char稍差些。



#### 128.mysql无则插入，有则修改，怎么实现？

1.方案一 加锁

无论通过synchronized锁、ReentranLock锁还是分布式锁，都可以解决该问题。缺点是，加锁会影响性能

2。方案二加索引

首先对唯一性的字段添加唯一索引ALTER TABLE tb_name ADD UNIQUE (col1、col2...)，，通过唯一索引即可保证数据的唯一性。

加入唯一索引后，通过INSERT INTO插入相同数据就会报错，此时需要使用REPLACE  INTO插入数据，用法是一样的。通过REPLACE  INTO插入数据时，若存在相同数据，会将之前的记录删除，再重新插入数据。缺点是，存在先删除再插入的过程，sql需要考虑全部数据列，不然会丢失部分列的数据。缺点是，建立唯一索引会影响插入效率。

3.方案三

通过预插入语句判断是否存在记录

通过预插入语句，尝试插入，判断修改的记录是否大于0，若大于0表示插入成功，若为0则表示记录已存在，需要执行更新操作。

原文连接：https://jiuaidu.com/jianzhan/455811/

#### 129.mysql如何把一个多行数据变成一列

**使用case…when…then**

使用IF() 进行行转列：

#### 130.mysql如何去重

1.通过MySQL DISTINCT：去重（过滤重复数据）

2.group by

3.row_number窗口函数

#### 131.mysql的in和exists有什么区别

子查询使用 exists，会先进行主查询，将查询到的每行数据循环带入子查询校验是否存在，过滤出整体的返回数据；子查询使用 in，会先进行子查询获取结果集，然后主查询匹配子查询的结果集，返回数据
外表内表相对大小情况不一样时，查询效率不一样：两表大小相当，in 和 exists 差别不大；内表大，用 exists 效率较高；内表小，用 in 效率较高。
不管外表与内表的大小，not exists 的效率一般要高于 not in，跟子查询的索引访问类型有关。

原文链接：https://blog.csdn.net/meism5/article/details/106247708

#### 132.开发中，mysql有什么规范？

基础：

 表存储引擎必须使用InnoDB

原因：  InnoDB 的特性主要有：
                        1. DML 操作(增、删、改)遵循 ACID(事务安全表) 模型，支持事务。
                                                2. 行级锁，提高并发访问性能。
                                                3. 支持外键（FOREIGN KEY）约束，保证数据的完整性和正确性

原文链接：https://blog.csdn.net/weixin_52850476/article/details/124634843

表字符集默认使用utf8，必要时候使用utf8mb4

命名规范：

库名，表名必须用小写，采用下划线分隔（注：正常情况在MySQL中是使用下划线作为单词分隔，但是由于历史表规范的问题，为了风格一致，表名禁止使用下划线）



列名单词首字母大写（注：正常情况在MySQL中是使用全小写，下划线进行单词分隔，但是由于历史表规范的问题，为了风格一致，禁止使用下划线）

库名，表名，列名必须见名知义，长度不要超过32字符

数据表、数据字段必须加入中文注释

库备份必须以bak为前缀，以日期为后缀

#### 133.开发中，java编码规范有哪些？

标识符规范：

```
1、包名：全部小写，用”.”隔开，每一个点表示一级目录，至少要有一级目录。

(1) 单级包：小写。如：com

(2) 多级包：小写，用”.”隔开。如：com.baidu.www

2、类或接口：所有单词首字母大写。(大驼峰法)

(1) 一个单词：首字母大写。如：Student、People

(2) 多个单词：每个单词首字母大写。如：HelloWorld、ServerSocket

3、方法或变量：第一个单词首字母小写，从第二个单词开始首字母大写。(小驼峰法)

(1) 一个单词：首字母小写。如：name、age

(2) 多个单词：第二个单词首字母大写。如：stuName、showTime

4、常量：全部大写，单词键以下划线”_”隔开

(1) 一个单词：全大写。如：PI、COUNT

(2) 多个单词：全大写，并以”_”隔开。如：RESULT_OK、WINDOW_HIERARCHY_TAG
```

注释规范：



缩进

编码规范

​	2、每条语句要单独占一行。尽管在Java中可以在一行当中写条语句，但为了使程序看起来更规范，且容易维护，要养成每行只写一条语句的好的编码规范。

​	3、用分号结束每条命令。语句要以分号结尾，程序代码中的分号必须为英文状态下的，初学者经常会将“; ”写成中文状态下的“;  ”，此时编译器会报出illegal character(非法字符)这样的错误信息。

​	4、声明变量时要分行声明。即使是相同的数据类型也应该放置在单独的一行上，以帮助添加注释。

​	5、Java语句中的多个空格看成一个。在Java代码中，关键字之间的多个空格均被视为一个。

文件名规范

​	1、类、变量和包的命名规则。在Java中，类名的第一个字母要大写;变量名、方法名和所有标识符的首字母都要小写，当有多个单词组合时，除了第一个单词外，其他的首字母都可以大写;包名应该全部是小写字母。



​	6、不要使用技术性强、难以理解或易混淆判断的语句。由于程序的开发和维护不可能由同一个人完成，为了将来便于维护程序，尽量使用简单的技术来完成程序需要的功能。

​	7、对于关键的方法要多加注释。多加注释会增加程序的可读性，有助于阅读者很快地了解代码结构。





#### 134.mysql中，如何实现批量插入？在mybatis里面又是如何实现

 insert into xxx values(),(),()

 <forEach></foreach>





#### 135.项目上线报bug，如何解决？



一. 评估bug的影响范围
1.分析bug影响的用户数量
2.分析bug影响的严重程度

3.回溯线上问题

检查其他业务是否有同类型的问题

分析bug产生的原因

二. 解决线上问题
bug影响范围比较小时一般都会通过修复bug的方式来解决，方法如下：
1.了解bug出现的场景，业务操作，努力复现bug
2.开发人员结合bug出现时的各种日志（系统日志、数据库日志、操作日志、debug日志），定位bug产生的原因
3.开发人员修改完成bug后，由测试人员进行验证，保证bug已被修复
4.按照项目规划的发布/升级的时间节点，将bug修复的代码发布到线上，bug解决
影响范围比较大的bug

 bug影响范围比较大时，如果还是通过修复bug的方式来解决，对用户的影响或者公司的损失无法把控，此时最重要的是：将问题范围降到最低。方法如下：
1.无法明确问题引入原因时，可以通过回滚版本的方式来规避
2.部分用户功能可以通过后台配置的方式将功能降级或关闭
3.如果是资源不足等性能问题时，可以通过重启系统或者扩容的方式解决，再进一步观察
以上几种规避问题的方法只是帮助我们争取到时间，规避问题后还是要按照之前修复bug的方式来定位问题，修复问题，并将修复的代码发布线上，将bug彻底解决。

三. 回溯线上问题
检查其他的业务是否有同类型的问题
分析bug出现的原因
补充操作出bug的测试用例

如果暂时解决不了，回溯上一个版本

#### 136.spring中的ioc和di有什么区别？

DI全程Dependency Injection，当某个java 实例需要另一个java实例时，创建被调用者的工作不是由调用者实现，而是由spring容器来完成，然后注入调用者，因此称为依赖注入。

Ioc全称Inversion of Control，把创建对象的权利交给容器，对象的实例不再由调用者来创建，而是由容器来创建，容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由应用代码转移带了容器，控制权发生了反转，这就是控制反转。它是spring框架的核心思想之一。

IoC和DI的区别
IoC和DI其实是同一概念的不同角度描述。IoC强调的是将对象实例的创建控制权由spring容器来统一管理，需要的时候从容器中取出，而不是由调用者自身去创建，从而达到降低代码耦合性与硬代码的目的。依赖注入强调的是当调用者需要使用对象实例时，spring容器为调用者提供对象实例这个过程。本质上应该是属于同一技术实现方式，但是在不同的情况，叫法不同。

#### 137.springboot和springcloud有什么区别？

springboot和springcloud的区别主要是:

1.作用不同；前者的作用是为了提供一个默认配置，从而简化配置过程；后者的作用是为了给微服务提供一个综合管理框架。

2.使用方式不同；前者可以单独使用；springcloud必须在springboot使用的前提下才能使用。springboot和springcloud都是从spring生态圈中衍生出来的软件开发框架，但是二者的创作初衷是完全不同的，springboot的设计目的是为了在微服务开发过程中可以简化配置文件，提高工作效率，而springcloud的设计目的是为了管理同一项目中的各项微服务，因此二者是完全不同的两个软件开发框架。

#### 138.select *  from  A for update 这是什么锁？表锁什么时候会升级为行锁？

如果查询条件用了索引/主键，那么select … for update就会进行行锁。
如果是普通字段(没有索引/主键)，那么select … for update就会进行表锁。

若mysql未命中索引或索引失效时，表级锁变行级锁。

#### 139.你在项目中做了哪些模块？简述这些模块用到什么技术，如何使用的？

#### 140.maven如何排除依赖

1.下载maven helper插件
2.查看依赖冲突
3.解决冲突

#### 141.maven的聚合和继承分别有什么用？

继承：描述的是两个工程之间的关系

聚合：用于快速构建项目

 相同点：
     聚合与继承的pom.xml中的打包方式都是pom

 不同点：
    继承是在子模块中配置与父工程之间的关系
聚合是在当前模块中配置与其他模块的引用



