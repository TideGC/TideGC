### 1.11 15个问题

#### 97. 哪些情况下导致mysql的索引会失效？

1. 联合索引不满足最左匹配原则（联合索引）。

    最左匹配原则指的是，以最左边的为起点字段查询可以使用联合索引，否则将不能使用联合索引。

2. 模糊查询最前面的为不确定匹配字符（like前有%）。

3. 索引列参与了运算。

4. 索引列使用了函数。

5. 索引列存在类型转换。

6. 索引列使用 is not null 查询。

7. or关键字的前后只要有非索引列的列

8. 查询条件左边的值未确定

#### 98. Mybatis中的#和$有什么区别？

两者的区别：使用#parameterName方式引用参数的时候，Mybatis会把传入的参数当成是一个字符串，自动添加双引号。$parameterName引用参数时，不做任何处理，直接将值拼接在SQL语句中。

\#是一个占位符，$是拼接符

补充：

```ini
如何防止SQL注入

使用#能够防止SQL注入，$不能避免注入攻击

#的方式引用参数，mybatis会先对SQL语句进行预编译，然后再引用值，能够有效防止SQL注入，提高安全性。

$的方式应用参数，SQL语句不进行预编译。
```



#### 99. 在 MyBatis 中怎么解决实体类属性名和表字段名不一致的问题？

　解决办法一: 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致，这样就可以表的字段名和实体类的属性名一一对应上了，这种方式是通\*过在sql语句中定义别名来解决字段名和属性名的映射关系的。

　　解决办法二： 通过<resultMap>来映射字段名和实体类属性名的一一对应关系。这种方式是使用MyBatis提供的解决方式来解决字段名和属性名的映射关系的。

#### 100. 什么是 MyBatis 的一级缓存和二级缓存？

1、一级缓存简介（默认缓存，无需开启）

一级缓存作用域是sqlsession级别的，同一个sqlsession中执行相同的sql查询（相同的sql和参数），第一次会去查询数据库并写到缓存中，第二次从一级缓存中取。

一级缓存是基于 PerpetualCache 的 HashMap 本地缓存，默认打开一级缓存。
2、何时清空一级缓存

如果中间sqlSession去执行commit操作（执行插入、更新、删除），则会清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。

一级缓存时执行commit，close，增删改等操作，就会清空当前的一级缓存；当对SqlSession执行更新操作（update、delete、insert）后并执行commit时，不仅清空其自身的一级缓存（执行更新操作的效果），也清空二级缓存（执行commit()的效果）。
3、一级缓存无过期时间，只有生命周期

MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个Executor对象，Executor对象中持有一个PerpetualCache对象，见下面代码。当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。


2、mybatis二级缓存（需要手动开启）
1、二级缓存简介

它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。

二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。
2、二级缓存何时存入

在关闭sqlsession后(close)，才会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。

开启了二级缓存后，还需要将要缓存的pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中。
3、二级缓存有过期时间，但没有后台线程进行检测

需要注意的是，并不是key-value的过期时间，而是这个cache的过期时间，是flushInterval，意味着整个清空缓存cache，所以不需要后台线程去定时检测。

每当存取数据的时候，都有检测一下cache的生命时间，默认是1小时，如果这个cache存活了一个小时，那么将整个清空一下。

4、当 Mybatis 调用 Dao 层查询数据库时，先查询二级缓存，二级缓存中无对应数据，再去查询一级缓存，一级缓存中也没有，最后去数据库查找。

原文链接：https://blog.csdn.net/guorui_java/article/details/118095020

#### 101. 如何自定义启动器 Spring Boot 中的 Stater？

- 引入SpringBoot Stater启动器依赖 
- 需要专门写一个类似spring-boot-autoconfigure的配置模块
- 用的时候只需要引入启动器starter，就可以使用自动配置了
- 命名：xxx-Spring-boot-Starter

#### 102. 简述springboot启动流程

SpringBoot启动流程大概：

1.初始化SpringApplication

​    根据项目的配置情况和Conditional条件来推断是否是一个Web应用。

  读取所有jar包下面spring.factories文件，解析放入缓存，然后读取ApplicationListener为key的监听器，后续在           SpringBoot加载的过程中会基于事件发布来做很多扩展通知。

2.真正的run方法开始执行，记录开始执行时间stopwatch。

3.读取所有的监听器，放入SpringApplicationRunListeners中，以便支持后续的事件发布订阅。

4.发布ApplicationStartingEvent事件，属于是一个Startup开始事件，感兴趣的监听器就会执行具体对应的startup方法。

5.基于监听器，加载yml或者properties文件，再根据配置文件中指定的spring.profiles.active环境来激活指定的环境配置，来设置Environment对象。

6.发布ApplicationEnvironmentPreparedEvent事件，感兴趣的监听器就会触发具体的方法。

7.打印SpringBoot的Logo、Banner（不重要）。

8.实例化Spring的上下文对象：AnnotationConfigServletWebServerApplicationContext。

9.applicationContext#setEnvironment()，将环境变量配置对象Environment设置到上下文中，然后执行ApplicationContextInitializer初始化上下文对象。

10.发布ApplicationContextInitialzedEvent事件，感兴趣的监听器执行对应的容器初始化方法。

11.解析启动类为BeanDefinition对象，以便后续IOC流程。

12.发布ApplicationPreparedEvent事件，感兴趣的监听器执行对应的方法。

13.#refresh()方法执行，和Spring的refresh不同的是，这个子类是AnnotationConfigServletWebServerApplicationContext。

14.在#refresh()方法中，除了执行IOC的流程外，后面还会执行#onRefresh()方法，这个方法里面就会创建servlet容器，注册DispatcherServlet。

15.计算启动总耗时，打印。

16.发布ApplicationStartedEvent事件，感兴趣的监听器执行对应的started方法。

17.发布ApplicationReadyEvent事件，感兴趣的监听器执行对应的就绪方法。

18.回调2个内置的扩展自动触发方法：
    回调实现了ApplicationRunner接口的类，且自动执行覆写的run方法。
    回调实现了CommandLineRunner接口的类，且自动执行覆写的run方法。

19.如果启动过程中发生了异常，则发布ApplicationFailedEvent，监听器执行具体的异常处理方法。


原文链接：https://blog.csdn.net/qq_42290561/article/details/125962867

#### 103. spring中常用的注解有哪些？

##### 1、给容器中注入组件

（1）包扫描+组件标注注解

@Component：泛指各种组件

@Controller、@Service、@Repository都可以称为@Component。

@Controller：控制层

@Service：业务层

@Repository：数据访问层

（2）@Bean

导入第三方包里面的注解

（3）@Import

@Import(要导入到容器中的组件)；

（4）使用spring提供的FactoryBean（工厂Bean）

- 默认获取到的是工厂Bean调用getObject创建的对象

- 要获取工厂Bean本身，需要在id前面加一个&

    

    ##### 2、注入bean的注解

    @Autowired：由bean提供

    ```
    @Autowired可以作用在变量、setter方法、构造函数上；
    有个属性为required，可以配置为false；
    ```

    @Inject：由JSR-330提供

    ```
    @Inject用法和@Autowired一样。
    ```

    @Resource：由JSR-250提供

    @Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的，@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用。

    @Primary

    让spring进行自动装配的时候，默认使用首选的bean，和@Qualifier一个效果。

    

    

    ##### 3、@JsonIgnore

    （1）作用

    在json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。

    （2）使用方法

    一般标记在属性或者方法上，返回的json数据即不包含该属性。

    （3）注解失效

    如果注解失效，可能是因为你使用的是fastJson，尝试使用对应的注解来忽略字段，注解为：@JSONField(serialize = false)，使用方法一样。
    

    ##### 4、初始化和销毁方法

    （1）通过@Bean(initMethod="init",destoryMethod="destory")方法

    （2）通过bean实现InitializingBean来定义初始化逻辑，DisposableBean定义销毁逻辑

    （3）可以使用JSR250：@PostConstruct：初始化方法；@PreDestory：销毁方法。

    （4）BeanPostProcessor：bean的后置处理器，在bean初始化前后进行一些处理工作

    postProcessBeforeInitialization：在初始化之前工作；

    postProcessAfterInitialization：在初始化工作之后工作；

    

    ##### 5、Java配置类相关注解

    @Configuration

    声明当前类为配置类；

    @Bean

    注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式；

    @ComponentScan

    用于对Component进行扫描；

    ##### 6、切面（AOP）相关注解

    Spring AOP详细介绍

    Spring支持AspectJ的注解式切面编程。

    @Aspect 声明一个切面

    @After 在方法执行之后执行（方法上）

    @Before 在方法执行之前执行（方法上）

    @Around 在方法执行之前与之后执行（方法上）

    @PointCut 声明切点

    在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持

    ##### 7、@Bean的属性支持

    @Scope设置类型包括：

    设置Spring容器如何新建Bean实例（方法上，得有@Bean）

    ① Singleton

    （单例,一个Spring容器中只有一个bean实例，默认模式）,

    ② Protetype

    （每次调用新建一个bean）,

    ③ Request

    （web项目中，给每个http request新建一个bean）,

    ④ Session

    （web项目中，给每个http session新建一个bean）,

    ⑤ GlobalSession

    （给每一个 global http session新建一个Bean实例）

    ##### 8、@Value注解

    （1）支持如下方式的注入：

        注入普通字符
        注入操作系统属性
        注入表达式结果
        注入其它bean属性
        注入文件资源
        注入网站资源
        注入配置文件

    （2）@Value三种情况的用法。

        ${}是去找外部配置的参数，将值赋过来
        #{}是SpEL表达式，去寻找对应变量的内容
        #{}直接写字符串就是将字符串的值注入进去
    

原文链接：https://blog.csdn.net/guorui_java/article/details/107347754

#### 104. 简述一下 Spring MVC 的执行流程？

![image-20230111120537820](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230111120537820.png)

1、第一阶段：配置阶段

     配置阶段，主要是完成对xml配置和注解配置。
    
     具体步骤如下：
    
     首先，从web.xml开始，配置DispatcherServlet的url匹配规则和Spring主配置文件的加载路径
    
     然后，就是配置注解，比如@Controller、@Service、@Autowrited以及@RequestMapping等。

2、第二阶段：初始化阶段

    初始化阶段，主要是加载并解析配置信息以及IoC容器、DI操作和HandlerMapping的初始化。
    
    具体步骤如下：
    
    首先，Wer容器启动以后，会由Web容器自动调用DispatcherServlet的init()方法。
    
    然后，在init()方法中，会初始化IoC容器，IoC容器其实就是个Map。
    
    紧接着，根据配置好的扫描包路径，扫描出相关的类，并利用反射进行实例化，存放到IoC容器中。
    
    缓存之后，Spring将再次迭代扫描IoC容器中的实例，给需要自动赋值的属性自动赋值。哪些属性需要自动赋值呢？比如加了@Autowrited的属性。
    
    最后，读取@RequestMapping注解，获得请求url，将url和Method建议一对一的映射关系并缓存起来。我们可以简单粗暴地理解为缓存在一个Map中，它的Key就是url，它的值是Method。

  

3、第三阶段：运行阶段

    运行阶段，在Spring启动以后，等待用户请求，完成内部调度并返回响应结果。
    
    具体步骤如下：
    
    用户在浏览器输入url之后，Web容器会接收到用户请求。Web容器会自动调用doGet()或者doPost()方法。从doGet()或者doPost()方法中，我们可以获得两个对象，分别是request和response。通过request可以获得用户请求带过来的信息，通过response可以往浏览器端输出响应结果。
    
    然后，根据request中获得的请求url，可以从HandlerMapping中找到对应Method。
    
    接着，还是利用反射调用方法，将获得方法调用的返回结果。
    
    最后，将返回结果通过response输出到浏览器，用户就可以看到响应结果。

原文链接：https://blog.csdn.net/gupaoedu_tom/article/details/124424855

#### 105. 如何实现跨域（浏览器的限制）访问？

**JSONP** ：最常见的一种跨域方式，其背后原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去。

优点:JSONP的兼容性很好，在古老的浏览器中都可以运行。
  缺点：
      1.JSONP 只支持 GET 请求，不支持 POST 请求等其他类型的 HTTP 请求
      2.请求过程无法终止，导致弱网络下处理超时请求比较麻烦
      3.无法捕获服务端返回的异常信息

**CORS** :Cross-Origin Resource Sharing(跨域资源共享)是一种允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。
当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,后端在接受到请求后确定响应后会在Response Headers中加入一个属性:Access-Control-Allow-Origin,值就是发起请求的源地址浏览器得到响应会进行判断Access-Control-Allow-Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理。

```
优点:
      1.CORS 支持所有类型的 HTTP 请求。
      2.开发者可以是使用普通的 XMLHttpRequest 发起请求和获取数据，比起 JSONP 有更好的错误处理
  缺点：兼容性不太好
```

**服务器跨域** ：在前后端分离的项目中可以借助服务器实现跨域，具体做法是：前端向本地服务器发送请求，本地服务器代替前端再向api服务器接口发送请求进行服务器间通信，本地服务器其实就是个中转站的角色，再将响应的数据返回给前端

**postmessage跨域**： 在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和 Safari 4都支持postMessage。
该方法可以通过绑定window的message事件来监听发送跨文档消息传输内容。使用postMessage实现跨域的话原理就类似于jsonp，动态插入iframe标签，再从iframe里面拿回数据，私认为用作跨页面通信更加适合

原文链接：https://blog.csdn.net/weixin_43359799/article/details/123133558

#### 106.  forward 和 redirect 有什么区别？

forward又叫转发，表示转发，当请求来到时，可以将[请求转发](https://so.csdn.net/so/search?q=请求转发&spm=1001.2101.3001.7020)到其他的指定服务，用户端不知晓。

![image-20230111121556511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230111121556511.png)

redirect又叫重定向，表示转发，当请求发给A服务时，服务A返回重定向给客户端，客户端再去请求B服务。

![image-20230111121637376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230111121637376.png)



```
补充：2.使用forward注意事项

1.转发和被转发的请求类型必须一致，即全是GET或者POST

2.转发者方法不能被标识位@RestController或者@ResponseBody
3.使用redirect注意事项

1.redirect不支持post请求

2.redirect需要携带请求参数，需要在url地址中进行编码防止中文乱码。
4.两者的区别

1.从地址栏显示来说：

​forword是服务器内部的重定向，服务器直接访问目标地址的 url网址，把里面的东西读取出来，但是客户端 并不知道，因此用forward的话，客户端浏览器的网址是不会发生变化的。

​redirect是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的地址。

2.从数据共享来说：

​由于在整个定向的过程中用的是同一个request，因此forward会将request的信息带到被重定向的jsp或者 servlet中使用。即可以共享数据
​redirect不能共享

3.从运用的地方来说

​forword 一般用于用户登录的时候，根据角色转发到相应的模块
​redirect一般用于用户注销登录时返回主页面或者跳转到 其他网站

4.从效率来说：

​forword效率高，而redirect效率低

5.从本质来说：

​forword转发是服务器上的行为，而redirect重定向是客户端的行为

6.从请求的次数来说：

​forword只有一次请求；而redirect有两次请求，







原文链接：https://blog.csdn.net/m0_51728906/article/details/124305238
```



#### 107. springboot如何实现自定义类型转换？

1.创建一个类型转换器

  写代码实现将字符串转换为自定义对象的方法

2.在springMVC的配置类中注册自定义的类型转换器



#### 108. Spring 通知类型有哪些？

五大通知类型 ：

1、前置通知：在目标方法执行之前执行执行的通知

2、环绕通知：目标方法执行之前和之后都可以执行额外代码的通知

3、后置通知：在目标方成功执行之后执行的通知。

 4、异常通知：在目标方法抛出异常时执行的通知。

 5、最终通知：在目标方法执行之后执行的通知。

```
补充：
五种通知常见使用场景

前置通知：记录日志（方法被调用）

环绕通知：控制事务、权限控制（用来调用其他通知，无法保证通知）

后置通知：记录日志（方法已成功调用）

异常通知：异常处理、控制事务

最终通知：记录日志（方法已调用，但不一定成功）
---------------------------------------------------------

Spring5 中Aop五种通知执行的顺序

a. 在目标方法没有抛出异常的情况下：
前置-->连接点-->后置-->最终

b.在目标方法抛出异常的情况下：
前置-->连接点-->异常-->最终
  


原文链接：https://blog.csdn.net/inexaustible/article/details/124381407
```



#### 109. IoC 和 DI 有什么关系？

IOC（控制反转）

全称为：Inverse of Control .将对在自身对象中的一个内置对象的控制反转，反转后不再由自己本身的对象进行控制这个内置对象的创建，而是由第三方系统去控制这个内置对象的创建。简单来说就是把本来在类内部控制的对象，反转到类外部进行创建后注入，不在由类本身镜像控制，这就是IOC的本质

全称为Dependency Injection，意思是自身对象中的内置对象是通过注入的方式进行创建

IOC和DI的关系

ioc就是容器，di就是注入这一行为，那么di确实就是ioc的具体功能的实现。而ioc则是di发挥的平台和空间。所以说。ioc和di即是相辅相成的拍档。他们都是为了实现解耦而服务的

DI是如何实现的

依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入式更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象


原文链接：https://blog.csdn.net/qq_35936973/article/details/115872620

#### 110. Spring 注入方式有哪些？

Spring实例注入的三种方式：
 1.属性注入，即使用注解注入。

使用@Autowired、@Resource或@Inject注解注入。
1.1@Autowired：Spring提供，默认按照类型装配。必须要求要注入的对象存在，如果要允许空值，设置其required属性为true
1.2@Resource：J2EE提供，默认按照名称装配，名称可以通过name属性指定，默认取字段名进行查找并完成注入。找不到名称时才会按照类型进行装配。所以@Resource的作用其实和@Autowired类似，只不过是注入方式不同。

 2.set方法注入。
 3.构造方法注入。



原文链接：https://blog.csdn.net/weixin_45830664/article/details/126226803

#### 111. Spring 有几种实现事务的方式？

基于xml配置的 TransactionProxyFactoryBean的声明式事务管理

基于注解的 @Transactional 的声明式事务管理



原文链接：https://blog.csdn.net/weixin_41979002/article/details/119103633



#### 112. Spring 中的 AOP 的底层实现原理是什么？

> Spring AOP的底层都是通过代理来实现的
>
> - 一种是基于JDK的动态代理（默认）
>
>     JDK 动态代理是基于拦截器和反射实现的，不需要第三方库支持，只需要 JDK 环境即可
>
>     1. 必须实现 InvocationHandler 接口；
>     2. 使用 Proxy.newProxyInstance 产生代理对象；
>     3. 被代理的对象必须要实现接口；
>     4. 内部采用asm技术动态生成字节码；
>
> - 一种是基于CgLIB的动态代理
>
>     使用CGLIB来进行代理：
>
>     ```ini
>     1.创建Enhancer类对象，该类类似于JDK动态代理中的Proxy类。它就是用来获取代理对象的。注意该类是属于CGLIB里面的，所以我们要导入相对应的包。
>     
>     2.设置父类的字节码对象。使用CGLIB生成的代理类是属于目标类的子类的，也就是说代理类是要继承自目标类的。
>     
>     3.设置回调函数。
>     ```
>     若是有接口，则你可以使用JDK动态代理带来实现代理；若是没有接口，则你就可以使用CGLIB进行代理。
>     原文链接：https://blog.csdn.net/qq_56851614/article/details/124893906