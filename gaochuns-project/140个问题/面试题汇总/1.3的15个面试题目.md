# 2.3的15个面试题目

#### **1.写出冒泡排序的代码？**

```ini
@Test
    public void demo1(){
        int[] arr=Arrays.copyOf(SortUtil.initArray(30),20);
        System.out.println("排序前"+Arrays.toString(arr));
        System.out.println("排序后"+Arrays.toString(sort(arr)));

    }
    public int[] sort(int[] array){
        for (int i = 0; i < array.length-1; i++) {
            for (int j = 0; j < array.length-i-1; j++) {
                if(array[j]>array[j+1]){
                    //交换两个元素
                    int temp=array[j+1];
                    array[j+1]=array[j];
                    array[j]=temp;
                }

            }

        }
        return array;
    }
```

#### 2.写出快速排序的代码？

```ini
@Test
public void test(){
    int[] array=Arrays.copyOf(SortUtil.initArray(30),15);
    System.out.println("排序前"+Arrays.toString(array));
    quickSort(array,0,array.length);
    System.out.println("排序后"+Arrays.toString(array));
}
/*
快速排序的递归思路：每次排序不管别的数字，只把我自己放到合适的位置上，
然后从这个位置下刀分成左右两份，重复调用，处理思路一致
 */
public static void quickSort(int[] array,int leftBound,int rightBound){
    //当区域中的数只有一个或0个元素，则认为是天然有序的
    if(leftBound+1>=rightBound)
        return;
    //逻辑代码，原来的arr[leftBound]的数被调换到了pos位置（分区，把数组分成三份，左右调用自己）
    int pos = sort(array, leftBound, rightBound);

    //调用自己
    //左边array[leftBound,pos)
    quickSort(array,leftBound,pos);

    //右边array[pos+1,rightBound)
    quickSort(array,pos+1,rightBound);
}

/**
 *  为一个数组的 [leftBound, rightBound) 区间内的第一个元素
（即，array[leftBound]）找它在 [leftBoud, rightBound) 区间内的合适的位置，把它换到那里去。
 * @param arr
 */
public static int sort(int[] arr,int leftBound,int rightBound){
    int left=leftBound;
    int right=rightBound;
    int pivot=arr[leftBound];
    //为pivot找合适的位置
    while(true){
        // left 从左往右找，直到遇到比 pivot 大的数字
        while(arr[++left]<pivot){
            if(left==rightBound-1) // 或者是遇到了数组的右边界
                break;
        }
        // right 从右往左找，直到遇到比 pivot 小的数字
        while (arr[--right]>pivot){
            if(right==leftBound)// 或者是遇到了数组的左边界
                break;
        }
        //当左右指针交叉的时候
        if(left>=right)
            break;
        // 交换一对数字。
        swap(arr,left,right);
    }
    //把第一个数字换到合适的位置
    swap(arr,leftBound,right);

    //返回这个位置的下标，如果本就是有序的，相当于第一个位置和自己交换，
    //right是0，等下一次调用自己劈开的时候，左边区域就没有元素
    return right;
}
public static void swap(int[] array, int x, int y) {
    int temp = array[x];
    array[x] = array[y];
    array[y] = temp;
}
```



#### 3.arraylist和linkedlist有什么区别？它们的底层是什么？

1. ArrayList 访问更快，LinkedList 增删更快。

2. ArrayList 扩容是增加 0.5 倍，LinkedList 无需考虑扩容问题

3. ArrayList 内存总开销更小，但需要是连续内存空间，LinkedList 内存总开销更大，但可以利用零碎的内存空间，无需连续内存空间

    底层：ArrayList 也是基于动态数组的；LinkedList 是基于双向链表的

#### 4.hashset和treeset有什么区别？

区别：

1.底层不同，TreeSet底层是TreeSet是二叉树实现的，HashSet是[哈希表](https://so.csdn.net/so/search?q=哈希表&spm=1001.2101.3001.7020)实现的

2.Treeset中的数据是自动排好序的，HashSet数据是无序的

3.TreeSet不允许放入null值。HashSet可以放入null，但只能放入一个null

#### 5.hashmap底层如何存储数据？

```java
HashMap在底层是采用一个“数组和链表”存储数据
HashMap存储数据采用put方法
当put元素时，首先根据key计算出Hash值
然后再通过Hash值计算出在数组中的下标
然后再下标位置上放入相应的元素
```

#### 6.hashmap是如何减少hash冲突的？

1.采用单向链表，解决hash冲突，jdk1.7以前头部插入链表，jdk1.8以后采用尾部插入链表（为了解决头部链表循环的问题）

#### 7.hashmap和linkedhashmap有什么区别？

LinkedHashMap继承于HashMap，底层基于HashMap和双向链表来实现的，都是线程不安全的。

HashMap无序，LinkedHashMap有序，可分为插入顺序和访问顺序两种。

LinkedHashMap存储数据，还是跟HashMap一样使用Entry的方式，双向链表只是为了保证顺序。

HashMap的遍历速度和他的容量有关，而LinkedHashMap只跟实际数量有关。

LinkedHashMap按照插入顺序排序，HashMap基于哈希表乱序。

#### 8.collection和collections有什么区别？常用的collections方法有哪些？

区别：Collection 是接口，它是 List、Set 和 Queue 接口的父接口，是 Java 集合框架的 2 个顶层接口之一，Collections 是一个服务于 Collection 的工具类，它提供了一系列静态方法帮我们简化对 Collection<small>（及其子接口的实现类）</small>的操作。

常用的collections方法：

1.Collections.sort() 排序

2..Collections.swap()交换

3.Collections.rotate() 移动

4.Collections.reverse(）反转（比如数组倒叙）

5.Collections.indexOfSubList（）求位置（某个元素在数组中的位置）

6.Collections.frequency()算频次（某个元素在数组中出现的频率）

7.Collections.copy（）复制

#### 9.hashset是如何保证数据不重复的？

HashSet 底层最终使用到了 HashMap ，所以，这个问题的本质在于：HashMap 是如何保证数据不重复的？添加到 Set 中的值，会作为一个键值对的 key（value 为null）添加到 HashMap 中，首选比较键的hashCode是否相等，如果不相等则存入，如果相等再调用equals比较键的值是否相等，如果不相等，则存入，相等则不存入

#### 10.hashmap底层数据结构？

jdk<=1.7是数组+链表形式，jdk>=1.8是数组+链表+数组+链表

HashMap这一个类型底层涉及到3中数据类型，数组、链表、红黑树，其中查询速度最快的是数组，时间复杂度是O(1),

链表数据量少的时候还行，数据量过大性能就一般了，它的时间复杂度是O(N)，

红黑树在数据量打的时候性能会比链表要好，他的时间复杂度是O(logn)

这里在链表和红黑树这里性能对比其实在HashMap的扩容时，已经体现出来了，Hash值产生碰撞后，链表长度>8时会由链表转换为红黑树，而当红黑树的节点<6时，会由红黑树转换为链表，这就是二者的性能临界点。

#### 11.treeset是如何保证元素有序的？

TreeSet 除了实现了 Set 接口之外，还实现了 SortedSet ，而 SortedSet 接口要求它的实现类必须有自动排序能力。TreeSet 作为 SortedSet的实现类，自然必须有自动排序这种能力，所以元素肯定是有序的

#### 12.linkedhashset和linkedhashmap是如何维护元素的顺序的？

LinkedHashSet底层是一个 LinkedHashMap，底层维护了一个数组+[双向链表](https://so.csdn.net/so/search?q=双向链表&spm=1001.2101.3001.7020)。它根据元素的hashCode值来决定元素的存储位置,同时使用链表维护元素的次序, 这使得元素看起来是以插入顺序保存的。

#### 13.hashmap的扩容机制是什么？2倍

先创建16的数组，使用到0.75时候开始扩容，这个0.75就是扩容因子，扩容为原先的2倍
（jdk8中）:当链表中元素的个数达到8，同时数组中的个数超过64时，就会进化成红黑树（进一步提高查询效率）。 注：若链表中元素的个数到8，而数组未到64，则按数组容量*2进行扩容，直到扩容到64，再树化。

#### 14.hashmap是线程安全吗？如何解决hashmap线程不安全的问题？

线程不安全

解决：

1.使用 hashTable    （直接在方法声明上使用 **synchronized** 关键字。这样一来，不管线程执行哪个方法，即便只是读取数据，都需要锁住整个 **Hashtable** 对象）

2.使用SynchronizedMap 跟hashtable一样，上锁，统一时间只能有一个线程进行访问，但是构造方法需要传入一个 Map 类型的参数，也就是说它可以将非线程安全的 Map 转化为线程安全的 Map。

3.使用concurrentHashMap  （jdk1.8中ConcurrentHashMap通过 CAS+synchronized实现线程安全）

三者区别：https://segmentfault.com/a/1190000021144667

#### 15.hashmap出现hash冲突的时候，是怎么解决的？

解决方式：

1.开放地址法：也称线性探测法,就是从发生冲突的那个位置,按照一定次序从Hash表中找到一个空闲的位置, 把发生冲突的元素存入到这个位置。而在java种ThreadLocal就用到了线性探测法,来解决Hash冲突。

2.链式寻址法：通过单向链表的方式来解决哈希冲突，Hashmap就是用了这个方法。(但会存在链表过长增加遍历时间)

3.再哈希法：key通过某个哈希函数计算得到冲突的时候,再次使用哈希函数的方法对key哈希一直运算直到不产生冲突为止 （耗时间,性能会有影响）

4.建立公共溢出区:就是把Hash表分为基本表和溢出表两个部分，凡是存在冲突的元素，一律放到溢出表中