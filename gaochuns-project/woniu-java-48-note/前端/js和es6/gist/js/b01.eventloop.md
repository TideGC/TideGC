links: [[es6.目录]]

# 浏览器中的事件循环

## 1. 浏览器进程和线程

浏览器是多进程的，每当你打开一个 Tab ，都会有一个进程被系统创建出来。<small>这就是为什么你会在任务管理器中看见多个 chrome.exe 的原因。</small>

每一个 tab 都是一个浏览器 "渲染进程" 。<small>当然，除了一个（或多个）渲染进程，浏览器还有其它的进程，例如 GPU 进程等。</small>

渲染进程是浏览器最核心最重要的进程，而渲染进程下又有多个线程，其中与 JS 关系最大的就是 "JS 引擎线程" 。

我们常说的 "浏览器中的 JS 是单线程执行的" 指的就是浏览器<small>（的一个 Tab 中）</small>有且仅有一个线程执行你所编写的 JS 代码。

```text
浏览器
├── 其它进程
├── …
├── …
├── 渲染进程 1            // 一个 tab 一个进程
│   ├── JS 引擎线程       // 主线程
│   ├── HTTP 请求线程
│   ├── 定时触发线程
│   ├── 事件触发线程
│   └── GUI 线程
├── 渲染进程 2            // 一个 tab 一个进程
│   ├── JS 引擎线程       // 主线程
│   ├── HTTP 请求线程
│   ├── 定时触发线程
│   ├── 事件触发线程
│   └── GUI 线程
├── …
└── 渲染进程 N            // 一个 tab 一个进程
    ├── JS 引擎线程       // 主线程
    ├── HTTP 请求线程
    ├── 定时触发线程
    ├── 事件触发线程
    └── GUI 线程
```

JS 引擎线程也被称作 "主线程" 。


## 2. 事件循环和执行栈

JS 引擎线程在解析一段 JS 代码时，会将代码放在某个地方，这个地方就被称作"**执行栈**"<small>（也可以称之为调用栈）</small>，然后依次执行里面的函数<small>（代码）</small>。

> 在 JS<small>（和其它一些脚本语言）</small> main 方法是隐式的。

JS 引擎线程<small>（即，主线程）</small>会执行 JS 函数<small>（及其中代码）</small>，但是，JS 主线程它不会"等"。

我们知道异步代码的执行有 2 大显著特点："需要等" 和 "有回调" 。以定时任务<small>（setTimeout）</small>为例：

```js
setTimeout(() => {
    console.log("4")
},1000);
```

上述代码 "需要等" 1 秒钟，然后再执行指定的回调方法。同样的道理，AJAX 请求也是如此，"需要等"，等到收到 HTTP 响应，然后再执行回调。

**但是由于执行 JS 代码的 JS 引擎线程是单线程的，所以主线程只能执行回调，但不可能去 "等" 。**

当 JS 主线程执行到异步方法/代码时，它不会等，而是把它异步代码的回调交给其它的线程，让其他的线程等。当其他线程 "等到" 之后，再由其它线程将回调交还给主线程，让主线程执行。

还是以定时任务为例：

```js
console.log('1')
setTimeout(() => {
    console.log('2')
},1000);
console.log('3');
```

上述代码的输出时 "1 3 2" ：

- 主线程先执行 console.log('1') 输出 "1" ；
- 主线程执行 setTimeout ，因为需要等，而主线程它不会亲自"等"，所以它会让另一个线程<small>（定时任务线程）</small>去"等"，并把回调函数<small>（的代码）</small>交给它。
- 主线程安排完"其它"线程之后，继续向下执行，执行 console.log('3') 输出 "3"；
- "其它" 线程在 "等到" 1 秒之后，再将回调函数<small>（的代码）</small>交还给主线程，让主线程执行。所以，主线程执行 console.log('2') 输出 "2" 。

AJAX 请求的处理过程也是同样的道理。

> [!important] 重申
> 遇到需要"等"的情况，主线程它不会"亲自等"，都是别的线程在"帮它等"。

## 3. 任务队列

> 对于调用栈，当你调用某个方法时，这个方法有可能是直接压栈了，也有可能没有压栈，而是是"**入了队列**"。

上一段说过，**在遇到异步函数<small>（代码）</small>时，主线程会让其它线程"帮它等"，并把异步函数的回调函数<small>（的代码）</small>先交给其它线程。当其他线程"等到了"之后，其它线程会再把异步函数的回调交还给主线程，让主线程执行回调函数。**

这里的"交还"的过程，是通过任务队列实现的。

当其它线程帮主线程"等到"了之后，会将对应的异步函数的回调函数放到任务队列中，然后，主线程**在合适的时候**就是从任务队列中取出回调函数，压栈执行。

主线程在执行完当前调用栈中的所有方法之后，才会从任务队列中取出<small>（当初的某某异步函数的）</small>回调函数，压入调用栈，然后再执行。

> [!danger] 重点
> 调用栈不空，任务队列中的<small>（当初的某某异步函数的）</small>回调函数是不会执行的。

观察下面的代码，你会发现 "2" 会在很久之后才会输出：

```js
console.log('1')
setTimeout(() => {
    console.log('2')
},0);
console.log('3');

for (let i = 0; i < 10000; i++) {
  console.info('hello world');
}
```

因为，调用栈未清空之前，在任务队列中的定时任务回调<small>（console.log('2')）</small>一直都不会执行。

> [!note] 了解
> 主线程清空一次调用栈和任务队列，就被称作一个 tick 。

## 4. 宏任务队列和微任务队列


在具体实现上，上面所说的 "任务队列" 不止一个，而是有 2 个："微任务队列" 和 "宏任务队列" 。

尽管都是异步函数，但是异步函数和异步函数之间也是有区分的，这就导致了异步函数的回调函数也就有了"三六九等"。

有些异步函数的回调函数，未来会被放到名为 "微任务队列" 的任务队列中；而另一部分则是放到名为 "宏任务队列" 的任务队列中。

而主线程在清空调用栈之后，优先从微任务队列中取回调函数执行，只有在微任务队列中的回调都执行完之后，才会去宏任务队列中取回调执行。

> [!note] 简而言之一句话
> 微任务队列的优先级比宏任务队列的优先级高，在两个队列中都有回调函数等待被执行的情况下，一定是微任务队列中的回调函数限制性。

- 和我们有关的宏任务有：AJAX 请求的回调、定时器任务的回调。另外，鼠标点击、键盘按下等事件的回调也属于宏任务。

- 和我们有关的微任务有：Promise 对象的成功<small>（fulfilled）</small>回调、Promise 对象的失败<small>（rejected）</small>回调。

> [!note] 提示
> 创建 Promise 对象时，会传给构造器一个 lambda 表达式。这个 lambda 表达式的执行是同步的，不是异步的。

```js
console.log('同步代码1');
setTimeout(() => {
    console.log('定时任务的回调'); 
}, 0);  // 这里的 0 ，在底层实现上实际是 4 毫秒，它不是真正的 0 。
new Promise((resolve) => {
    console.log('同步代码2');
    resolve();
}).then(() => {
    console.log('Promise的成功回调');
});
console.log('同步代码3');
```

> [!note] 一个小细节：定时任务的 0 毫秒后
> 如果给定时任务传 0 毫秒：setTimeout(func, 0)，实际上并没有真正的 0 毫秒。这里的实际的值是 4 ，即，表示 4 毫秒后。
> 
> 当然，无论是真正的 0 毫秒之后，还是实际的 4 毫秒之后，都不会改变定时任务的回调一定是在调用栈中的代码被"清空"之后才有机会执行这个事实。


## 5. 案例

### 案例一

```js
// 执行结果：1 3 2

console.log(1);

setTimeout(function () {
  console.log(2);
}, 0);

console.log(3);
```

上述代码 3 条语句：

- 一个打印
- 一个定时器
- 一个打印

先执行第一个打印，输出 1 ，然后由于 setTimeout 是异步操作，"等"这个事由「其它线程」来"等"，主线程继续向下执行。接着执行第二个打印，输出 3 。

现在主线程的调用栈"清空"了，主线程考虑 "先微后宏" 地从任务队列中取代码执行。而微任务队列中是空的，宏任务队列中方的是其它线程在"等到"了之后房间来的定时任务的回调。所以，主线程执行了打印，输出 2 。

所以最终的执行结果是 1 3 2 。


### 案例二

```js
// 最终执行结果：1 2 4 3

console.log(1);
new Promise(function(resolve,reject) {
    console.log('2');
    resolve();
}).then(function() {
    console.log(3);
})
console.log(4);
```

上述代码 4 条语句：

- 一个打印
- 一个 new promise 及其参数函数
- 一个 promise.then
- 一个打印

先执行第一个打印，输出 1 ，然后执行 new Promise ，由于 new Promise 是同步代码，它的参数函数代码会立即执行，所以会执行 `console.log(2)` 输出 2 。

当执行到 resolved() 时，Promise 对象的状态从"初始态"变为了"成功态"，那么当前线程（也就是主线程）会将 Promise 对象的成功回调放入到微队列中。然后主线程继续向下执行。

紧接着执行 `console.log(4)` 输出 4 。因为调用栈已经"清空"，最后主线程再取出微队列中的 Promise 对象的成功回调 `console.log(3)` 执行，输出 3 。

所以最终的执行结果是 1 2 4 3。

### 案例三

```js
// 最终结果：1 5 11 6 2 3 4 7 8 10 9
console.log('1');
    
setTimeout(function () {
    console.log('2');
    new Promise(function (resolve) {
        console.log('3');
        resolve();
    }).then(function () {
        console.log('4')
    })
}, 0);
  
new Promise(function (resolve) {
    console.log('5');
    resolve();
}).then(function () {
    console.log('6')
});

setTimeout(function () {
    console.log('7');
    new Promise(function (resolve) {
        console.log('8');
        resolve();
    }).then(function () {
        console.log('9')
    })
    console.log('10')
}, 0);
   
console.log('11');
```

这段示例比较复杂，我们人为地分为 2 个阶段分析：

> [!note] 第一阶段

- 首先会执行第一个打印，输出 1 ；

- 然后第 1 个 setTimeout 定时任务，让其它线程去"帮忙等"，主线程则继续向下。其它线程在"等到"后，会将定时任务1的回调放入宏队列中；

- 接着执行第 1 个 new Promise 及其参数函数，因此会输出 5 。在输出 5 之后，主线程因为执行了 resolve() 方法，导致 Promise 对象变成"成功态"，进而导致 Promise 的成功回调被放入微队列中；

- 主线程继续向下，遇到第 2 个 setTimeout 定时任务，它又是让其它线程"帮忙等"，而其它线程在"等到"后，会将第二定时任务的回调放入宏队列中。

- 主线程继续向下，执行 `console.log(11)` 输出 11 。截止目前为止，输出的是 1 5 11 。此时，调用栈已经"清空"了，主线程接下来会"先微后宏"地从任务队列中取回调函数<small>（放入调用栈）</small>执行。

> [!note] 第二阶段

因为，调用栈已经"清空"了，所以主线程接下来会"先微后宏"地从任务队列中取回调函数<small>（放入调用栈）</small>执行。

- 先从微队列中取函数放到调用栈中执行。现在微队列中有且仅有 Promise 的成功回调函数<small>（`console.log(6)`）</small>。取出，放到调用栈中执行。

- 现在，调用栈和微队列都"清空"，主线程就需要从宏队列中取函数执行。宏队列中"排在前面"的是 "定时任务1" 的回调函数，将其取出，放至调用栈中执行：
  - 先输出 2 ；
  - 然后执行 new Promise 及其参数函数，输出 3 ；
  - 然后因为执行了 resolve 方法，Promise 对象的成功回调函数（`console.log(4)`） 被放入微队列。

> [!import] 现在为对立中又有代码了！

- 因为调用栈空了，主线程又要从队列中取代码放入调用栈执行，因为现在微队列中又有了代码（Promise 的成功回调）。所以，被取出执行的是：输出 4 。

- 现在调用栈和微队列又全空了，主线从又要从宏队列中取代码，执行第 2 个的回调，打印 7 和 8 ，将 promise.then 的回调放入微队列后，继续打印 10 。

- 最后，主线程从微队列中取出 Promise 的成功回调 `console.log(9)` 执行，输出 9 。


### 案例四

```js
// 1 5 2 3 4
new Promise((resolve) => {
    console.log("1")
    resolve()
}).then(() => {
    console.log("2")
    setTimeout(() => {
        console.log("3")
    }, 0)
})

setTimeout(() => {
    console.log("4")
},1000);

console.log("5")
```


- 首先 `new Promise` 执行及其参数函数，执行 `console.log(1)` 输出 1 ，而后 Promise 的成功回调被放进微队列。<small>注意，回调中有个定时任务的调用，这个调用要到回调函数执行时才执行。</small>

- 主线程继续向下执行，遇到代码中的第二个定时任务<small>（实际上是第一个执行的定时任务）</small>。主线程会委托其它线程 "帮忙等" 1 秒，主线程则继续向下。其它线程会在 4 秒后将定时任务的回调放进宏队列。

- 主线程执行 `console.log(5)` 输出 5 ，至此，调用栈是被"清空"了。接下来主线程要从微任务队列和宏任务队列中取代码执行。

- 因为微任务队列优先级高，所以，主线程先取出 Promise 的成功回调函数执行，输出 2 ，然后遇到了<small>（代码顺序）</small>的第一个定时器<small>（实际执行顺序的第二个定时器）</small>。主线程会委托其它线程 "帮等" 0 秒，然后在 0 秒后由其它线程将定时器回调放入宏队列。

- 由于代码顺序的第一个定时任务（执行顺序的第二个定时任务）的等待时间更短，所以，它的回调函数在先入宏队列，所以先执行，console.log('3') 。而代码顺序的第二个定时任务（执行顺序的第一个定时任务）的等待时间更长，所以它的回调函数后执行，输出 4 。

