---
alias: 
- eventbus
tags: 
- vue
- eventbus
---

links: [[d04.组件通信]]

# eventbus

```dynamic-embed
![[202302271132]]
```

## Vue 中的订阅发布

[[202212270926|“Vue 发布订阅方案”的问题]]

考虑到发布订阅的代码中有大量的与功能无关的“套路型”代码，以及需要注意、避免的小坑，所以，有人<small>（有经验的程序员）</small>会将发布订阅代码进行二次封装：EventBus 。

除了由专门的资深组员实现，或者直接 copy 以前项目已有的、经证明过的、现成的实现之外，还可以使用高质量的第三方实现。比如 [vue-bus](https://github.com/yangmingshan/vue-bus) 。

考虑到有些项目没有用到 eventbus ，而有些项目用的是自己实现的 eventbus ，所以 vue-bus 的 300+ 的 star 已经是 github 上的最高的了。

### 第 1 步：安装、引用 vue-bus

- 如果是在 vue.js 中使用

```html
<!-- 
https://cdn.jsdelivr.net/npm/vue-bus/dist/vue-bus.js
https://unpkg.com/vue-bus/dist/vue-bus.js
-->  

<!-- 开发版 -->
<script src="https://cdn.jsdelivr.net/npm/vue-bus/dist/vue-bus.js"></script>

<!-- 线上版 -->
<script src="https://cdn.jsdelivr.net/npm/vue-bus/dist/vue-bus.min.js"></script>
```

- 如果是在 @vue/cli 中使用

```sh
npm install vue-bus --save
```

```js
import Vue from 'vue';
import VueBus from 'vue-bus';
  
Vue.use(VueBus);
```

## 使用

### 第 2 步：编写绑定和解绑代码

这部分代码是写在父组件中的。并且，on 和 off 方法的调用理应成对出现，才能避免上述的发布订阅的"坑"。

```js
// …
created() {
  this.$bus.on('xxx', this.addTodo);
  this.$bus.once('yyy', this.addTodo);
},
beforeDestroy() {
  this.$bus.off('xxx', this.addTodo);
},
```

由于 once 方法是一次性的，所以，

### 第 3 步：编写“被触发”方法

未来，addTodo 方法会 "被" 触发执行。

```js
methods: {
  addTodo(newTodo) {
    this.todos.push(newTodo);
  }
}
```

### 第 4 步：编写触发代码

这部分代码是写在子组件中的。

```js
// …
methods: {
  addTodo() {
    this.$bus.emit('xxx', { text: this.newTodoText });
    this.$bus.emit('yyy');
    this.newTodoText = '';
  }
}
```

### 其它方式使用

- once() 方法的绑定是一次性的，所以，我们的代码中没有与 once 配套 off 。在 once 所指定的方法执行过一次之后，它就会自动失效。

- 除了通过 this 来调用 emit 方法之外，还可以通过 Vue 对象来调用 emit 方法。
```js
// xxx.js
import Vue from 'vue';

Vue.bus.emit('someEvent');
```

_Note: `on` `once` `off` `emit` are aliases for `$on` `$once` `$off` `$emit`. See the [API](https://vuejs.org/v2/api/#Instance-Methods-Events) for more detail._


## 示例

> [!note] 预期效果
> 子组件中有一个输入框，当子主键中的输入框的内容更新时，父组件中的 \<p\> 元素的内容同步更新。

### 定义子组件

```html
<template>  
    <div>
        <h4>我是子组件</h4>  
        <p><input type="text" v-model="msg"></p>  
        <p>{{msg}}</p>  
    </div>
</template>  
  
<script>  
export default {  
    name: "Son",  
    data() {  
        return {  
            msg: ''  
        }  
    },  
}  
</script>
```

### 定义父组件

```html
<template>  
    <div>
        <h4>我是父组件</h4>  
        <p>{{ val }}</p>  
        <Son></Son>
    </div>
</template>
  
<script>
import Son from "@/components/Son";
export default {
  name: "Parent",
  components: {Son},
  data() {
    return {
      val: ''  
    };  
  },  
}  
</script>
```

### 子组件使用 eventbus

- 第 1 点：子组件为 data 数据添加监听器，并发出事件。

```js
  
watch: {  
  msg() {  
    this.$bus.emit("input-val", this.msg);  
  }  
},
```

- 第 2 点：父组件绑定事件监听，并指定事件处理器：

```js
created() {  
  this.$bus.on('input-val', this.getValFromParent);  
},  
beforeDestroy() {  
  this.$bus.off('input-val', this.getValFromParent);  
},  
methods: {  
  getValFromParent(newVal) {  
    this.val = newVal;  
  }  
}
```




