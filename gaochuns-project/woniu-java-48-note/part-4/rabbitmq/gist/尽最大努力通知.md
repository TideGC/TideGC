---
alias: 
- 尽最大努力通知
tags: 
- rabbitmq
- 方法论
---

# 尽最大努力通知

> [!tip] 这里实现的目标有 2 个
>  1. 因客观有原因导致的发送失败之后，要有重试，不能立刻放弃。<small>而且，重试不应该是立刻重试，因为大概率仍会失败，无意义。</small>
> 
> 2. 消费者是否接收到了消息，消息的发送方必须明确知晓。


解决方案的几个核心思路点：

1. B 最后需要通过 OpenFeign 来“告知” A 某某消息已经收到了。不能是发消息通知，否则就进入了“套娃”场景。

2. B 无论在收到消息后的代码是执行成功，还是失败，这条消息一定是不会重新入队的。否则，就有可能进入“死循环”的场景。

3. 基于上述第 2 点，所以，重发消息来实现“饱和式攻击”不能靠 rabbitmq server 重新入队的机制来做，而是靠 A 自己来重发。

4. 基于上述第 3 点，B 有可能会收到重复消息，所以 B 要做消息的去重<small>（避免代码的重复执行）</small>。

5. B 的代码应该在一个事务中，哪怕最后一个 OpenFeign 执行失败了，整个逻辑都要回滚，就当作从来都没收到这条消息的。


## 1. 简单方案

我们以一个模拟的、无意义的业务逻辑来描述下属方案：

1. 在 department-service 处删除某部门；
2. 删除部门后，department-service 要发出消息，通知 employee-service 去“调整”原来属于这个部门下的员工的信息<small>（他们的 department-id 置 null）</small>。

### 第 1 步：消息发送方新增本地消息表

在 department-service 的本地数据库中添加一张消息表，形如：

``` sql
drop table if exists `message`;
create table `message`
(
    `id`              BIGINT AUTO_INCREMENT,
    `exchange`        VARCHAR(128)  COMMENT '要发往的交换机',
    `routing_key`     VARCHAR(128)  COMMENT '消息的路由键',
    `message_content` VARCHAR(4096) COMMENT '消息的内容',
    `status`          VARCHAR(128)  COMMENT '消息的状态：发送中、已发送、已接收',
    `retry_count`     INT           COMMENT '重发次数',
--  `version`         BIGINT        COMMENT '乐观锁',
    PRIMARY KEY (`id`)
) ENGINE = InnoDB;
```

其中：

- **retry_count** 是配合定时任务实现消息重发；
- **version** 是用来实现乐观锁的。
- 极简情况下，这两个字段可以没有，那么整个功能就更简单一些。

在 department-service 做完 `删除部门` 的业务操作后，要向消息表中添加一条记录，表示有一条待发送消息。

> [!important] 注意
> department-service 的本身的操作和向消息表中添加记录这两个操作要在同一个事务中。

```java
@Transactional
public void deleteDepartment(Long id) {
    log.debug("删除部门 {}", id);
    departmentMapper.deleteById(id);

    log.debug("删除部门成功，准备发送消息出去…");
    Message message = new Message("Q1", "hello world");
    messageMapper.insert(message);
}
```

### 第 2 步：编写定时任务发送消息（上）

在 department-service 中真正发消息的是[[07.spring-task|定时任务]]，它周期性地从本地消息表中取出待发送消息进行发送。

待发送消息的标准是：消息状态为 `发送中` 并且发送次数未耗尽。

```java
@Scheduled(fixedRate = 6000)
public void handle() {
    log.debug("定时任务开始干活，发送消息…");

    // 查询待发送消息：status = '发送中' and retry_count > 0
    QueryWrapper<Message> qw = new QueryWrapper<Message>()
            .eq("status", "发送中")
            .gt("retry_count", 0);

    List<Message> messageList = messageMapper.selectList(qw);
    if (messageList.isEmpty()) {
        log.debug("没有待发送消息");
        return;
    }

    log.debug("有 {} 条消息等待发送", messageList.size());

    // 未完待续…

}
```


### 第 3 步：确认消息发送成功或失败（上）

生产者为了明确知道发送到了 RabbitMQ 或发送失败，因此需要开启『发送者确认』功能。

- 配置文件

``` properties
# 确认消息已发送到交换机（Exchange）
spring.rabbitmq.publisher-confirm-type=CORRELATED
```

- 设置回调方法

```java
@Configuration
@EnableRabbit
public class RabbitMQConfig {
    
  …
    
  @Bean
  public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate rabbitTemplate = new RabbitTemplate();
        rabbitTemplate.setConnectionFactory(connectionFactory);
      
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
        
            if ( ack ) {
                log.debug("消息成功投递至 RabbitMQ（ 的 Exchange ）");
                // 未完待续 …
            } else {
                log.debug("消息未能成功投递到 RabbitMQ（ 的 Exchange ）");
                // 未完待续 …
            }
        
            // 未完待续 …
        });
        
        return rabbitTemplate;
    }
}
```

### 第 4 步：使用 CorrelationData 

在使用 RabbitTemplate 发送消息时，可以多传入一个 CorrelationData 类型的参数。它通常作为 `.convertAndSend()` 方法的最后一个参数。

```java
CorrelationData data = …
// 发送消息
rabbitTemplate.convertAndSend(…, …, …, …, data);
```

在发送消息时你传入 convertAndSend 方法的 CorrelationData 对象会作为第一个参数再次传到你的回调方法中。

```java
// 就是这里的第一个参数
rabbitTemplate.setConfirmCallback( (correlationData, ack, cause) -> {
    …
} );
```

CorrelationData 有一个 String 类型的属性 `id` ，你可以通过 CorrelationData 的有参构造为这个 id 属性赋初值：

```java
CorrelationData data = new CorrelationData("…");
// 发送消息
rabbitTemplate.convertAndSend(…, …, …, …, data);
```

`id` 属性的值应该是唯一的，逻辑上，它能唯一标识 convertAndSend 所发出去的这个消息。

未来<small>（ 在回调中 ）</small>，你可以再通过它的 `.getId()` 方法，把这个 `id` 属性值再取出来：

```java
// 就是这里的第一个参数
rabbitTemplate.setConfirmCallback( (correlationData, ack, cause) -> {
    String id = correlationData.getId();
    …
} );
```

### 第 5 步：确认消息发送成功或失败（下）

我们利用 CorrelationData 对象，在发送消息的时候，将消息的<small>（ 消息表中的 ）</small>ID 作为 CorrelationData 对象的 `id` 属性的值，保存在 CorrelationData 对象中：

```java
String idStr = String.valueOf(message.getId()); // Long -> String
CorrelationData correlationData = new CorrelationData(idStr);
// 发送消息
rabbitTemplate.convertAndSend(exchange, routingKey, messageContent, correlationData);
```

未来，在回调中，我们可以将这个 ID 再取出来，这样就能确定：本次回调是哪一次 converAndSend() 方法所对应的回调。

```java
rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
        String idStr = correlationData.getId();
        Long id = Long.parseLong(idStr);        // String -> Long
        Message message = messageMapper.selectById(id);

        if (ack) {
            log.info("消息 {} 已发送到 RabbitMQ（的 Exchange）", id);
            // 未完待续 …
        } else {
            log.info("消息 {} 未能成功发送到 RabbitMQ（的 Exchange）", id);
            // 未完待续 …
        }

        // 未完待续 …
});
```


---

消费者发送消息至 RabbitMQ 成功，那么执行数据库操作，将 message 表中的该消息的状态改为成功<small>（或等价的其它）</small>状态。

如果发送消息失败，那么有 2 种后续处理方式：

1. 和成功的情况一样，直接修改数据库中的消息的状态，改为失败。（当然这种只发送一次的一锤子买卖并不人性）。

2. 结合表中的 **retry_count** 字段和 Spring Task 功能，实现一个定时任务。不停地从消息表中取出待发送消息，直至消息发送成功，或重试次数耗完。

```java
@Slf4j
@Component
public class SendMessageTimerTask {

    @Autowired private RabbitTemplate rabbitTemplate;
    @Autowired private MessageMapper messageMapper;

    // 定时任务：每隔 5 秒从数据库中读取未发送的消息发送到 RabbitMQ
    @Scheduled(fixedDelay = 5 * 1000)
    private void autoSend() {
        log.debug("定时任务起来干活…");
        // 查询条件是：（状态不是 “已接收” 且发送次数 “大于 0”）的消息，都需要发送。
        Wrapper<Message> wp = new QueryWrapper<Message>();
        qw.ne("status", "已接收")   // status != "已接收"  
          .gt("retry_count", 0);    // retry_count > 0
        List<Message> messageList = messageMapper.selectList(wp);

        if (messageList.size() == 0) {
            log.debug("没有消息需要投递");
            return;
        }

        log.debug("查询符合条件的待发送消息，共[{}]条", messageList.size());

        // 循环发送所有待发送消息
        for (Message message : messageList) {
            CorrelationData data = new CorrelationData(message.getId().toString());
            log.debug("发送消息[{}]", data.getId());
            // 可靠消息服务投递的消息的真实内容 == "消息的ID:消息的原始内容"
            String realContent = message.getId() + ":" + message.getMessageContent();
            rabbitTemplate.convertAndSend(
                    message.getExchange(),
                    message.getRoutingKey(),
                    realContent,
                    data
            );

            // 在回调用去减消息的发送次数。
        }
    }
}
```

如果考虑到 A 服务可能会部署多个，那么这里可以再加上乐观锁以保证避免消息发送多次。


#### RabbitMQ 删除过期消息

由于存在消费者因故未能消费消息的可能，这会导致这些消息堆积在 RabbitMQ 中。因此需要在创建队列，或发送消息时指定过期时间，以便于让 RabbitMQ 将这些在规定时间内未能消费的消息移除。

```java
@Bean
public Queue queue() {
    Map<String, Object> arguments = new HashMap<>();
    arguments.put("x-message-ttl", 10 * 60 * 1000); // 10 分钟的过期时间
    return new Queue("user.register", true, false, false, arguments);
}
```

### 第 6 步：编写定时任务发送消息（下）

```java
/*
 * 循环遍历，发送消息
 */
for (Message message : messageList) {

    String exchange = message.getExchange();
    String routingKey = message.getRoutingKey();
    String messageContent = message.getMessageContent();    // 这里后续可改进
    log.debug("发送消息：[{}] [{}] [{}]", exchange, routingKey, messageContent);

    String idStr = String.valueOf(message.getId()); // Long -> String
    CorrelationData correlationData = new CorrelationData(idStr);

    if (message.getExchange().equals("")) {
        rabbitTemplate.convertAndSend(routingKey, (Object) messageContent, correlationData);
    } else {
        rabbitTemplate.convertAndSend(exchange, routingKey, messageContent, correlationData);
    }

}
```

### 第 7 步：消息接收者 HTTP 请求确认接收消息

-   改造`定时任务发送消息`处代码，需要将消息 ID 发给消息接收者：

```java
for (Message message : messageList) {
  String exchange = message.getExchange();
  String routingKey = message.getRoutingKey();
  // 在要发送的实际内容之前拼上这条消息的ID。
  String messageContent = message.getId() + ":" + message.getMessageContent();    
  log.debug("发送消息：[{}] [{}] [{}]", exchange, routingKey, messageContent);
    
  …
} 
```

-   编写代码，department-service 暴露一个 API ，等着被消息接收者调用，被调用后去修改消息状态

```java
@PostMapping("/message/received")
public String receivedMessage(@RequestParam("id") Long id) {
    Message message = messageMapper.selectById(id);
    message.setStatus("已接受");
    messageMapper.updateById(message);

  return "success";
}
```

- employee-service 开启接收者手动确认功能，因为，我们无论接收者这边是执行成功，还是执行失败，都不能让消息重新入队。

```properties
spring.rabbitmq.listener.simple.acknowledge-mode=manual
spring.rabbitmq.listener.direct.acknowledge-mode=manual
```

-   employee-service 收到消息，执行本地业务逻辑后，发起 HTTP 请求触发、修改 department-service 处的消息表中的消息。

```java
@Transactional
@RabbitListener(queues = "Q1")
public void handle(String msg, 
           Channel channel, 
               @Header(AmqpHeaders.DELIVERY_TAG) long tag) {

  // 手动确认收到消息
  channel.basicAck(tag, false);
  // xxx:yyy          , xxx 是消息表中的消息的ID，yyy 是业务逻辑中的、被删除掉的部门的id
  String[] split = StringUtils.tokenizeToStringArray(msg, ":");
  String messageIdStr = split[0];
  String departmentIdStr = split[1];

  Long departmentId = Long.parseLong(departmentIdStr);

  // 执行业务逻辑将：原来部门 id 是 xxx 的员工的 department_id 设置为 null 。
  employeeMapper.clearDepartmentIdOfEmployees(departmentId);



  /** 下述代码使用 RestTemplate "意思意思"，应该改为 OpenFeign 调用 **/

  // 准备请求头部信息。
  HttpHeaders headers = new HttpHeaders();
  headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

  // 准备请求参数
  MultiValueMap<String, Object> parameters = new LinkedMultiValueMap<>();
  parameters.add("id", messageIdStr); // id=xxx

  HttpEntity<MultiValueMap<String, Object>> entity = new HttpEntity<>(parameters, headers);

  String url = "http://127.0.0.1:8080/message/received";
  restTemplate.exchange(url, HttpMethod.POST, entity, String.class);
}    
```

