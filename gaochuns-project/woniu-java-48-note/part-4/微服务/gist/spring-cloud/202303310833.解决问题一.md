---
alias: 
  - OpenFeign 方案解决问题一
---

## OpenFeign 方案解决问题一

> [!cite] 前提
> 其实如果现实中真有这样的需求，我们通常是会使用 [[202211031343.解决问题一|RestTemplate]] 来解决这个问题。不过，考虑到 spring-cloud 中，我们未来会用 OpenFeign 来“淘汰”掉 RestTemplate，所以，我们这里就直接使用 OpenFeign 来解决这个问题。

### 第 1 步：添加依赖

为员工 spring-boot 项目引入必要的包：

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220922072853.png)

如果是手动添加，你需要向 pom.xml 中加入以下内容<small>（ 有 3 处，如果 1 和 2 已存在，则无需重复添加 ）</small>：

```xml
<properties>  
    …
    <spring-cloud.version>Hoxton.SR9</spring-cloud.version>  <!-- 1 版本号定义 -->
</properties>

<dependencies>
    …
    <dependency> <!-- 2 依赖包 -->
        <groupId>org.springframework.cloud</groupId>  
        <artifactId>spring-cloud-starter-openfeign</artifactId>  
    </dependency>
</dependencies>

<dependencyManagement>  
    <dependencies>
        …
        <dependency>  <!-- 3 导入 spring-cloud 官方的 dependencies -->
            <groupId>org.springframework.cloud</groupId>  
            <artifactId>spring-cloud-dependencies</artifactId>  
            <version>${spring-cloud.version}</version>  
            <type>pom</type>  
            <scope>import</scope>  
        </dependency>
    </dependencies>
</dependencyManagement>  
```

### 第 2 步：替换 OpenFeign 的底层实现（可选）

> 这一步是可选操作。

因为 OpenFeign 默认使用的 JDK 的 HttpURLConnection 性能低的离谱，所以实际场景中，通常会让 OpenFeign 去用别的第三方的库发 HTTP 请求。最常见的第三方库是 HttpClient 和 OkHttp 。

- [[202207270825#替换成 HTTPClient|替换成 HttpClient]]。HttpClient 作为老牌网络库，其市场占有率和相关资料最多。
- [[202207270825#替换成 OkHttp|替换成 OkHttp]] 。OkHttp 作为新兴的网络库，其性能还要略微由于 HttpClient 。

### 第 3 步：学习 OpenFeign 的注解（部分）

<mark style="background: #ADCCFFA6;">OpenFeign 复用了 Spring MVC 体系中的注解。</mark>

通过这些注解来“描述”，我们希望发出一个怎样的 HTTP 请求：

- 发给谁，发到哪里去？
- 是 GET 请求，还是 POST 请求？
- 携带的参数字符串格式是 json-string，还是 query-string？
- 携带的参数的内容是什么？
- 预期的返回值类型是什么？需不需要 OpenFeign 帮我们转成对象？
- …

#### @FeignClient 注解

@FeignClient 注解的 <mark style="background: #ADCCFFA6;">value/name</mark> 属性值<mark style="background: #CACFD9A6;">暂时任意，确保唯一即可</mark>。

@FeignClient 注解的 <mark style="background: #ADCCFFA6;">url</mark> 属性<small>（当前有用，未来用不上）</small>，表示了你希望 OpenFeign “帮你”向何处发出一个 HTTP 请求。

```java
@FeignClient(name = "DepartmentFeignClient", url = "http://127.0.0.1:8080")  
public interface DepartmentFeignClient {
    …
}
```


#### @GetMapping / @PostMapping 注解

在 OpenFeign 的“世界”中，我们通过 @GetMapping 注解和 @PostMapping 来表达我们需要 OpenFeign 帮我们发出一个什么样的请求？Get 请求还是 Post 请求？

另外，@GetMapping 注解和 @PostMapping 注解的 path / value 属性的值指定了请求的 URI 。

```java
@GetMapping("/") // 发出 HTTP Get 请求
public String index();

@PostMapping("/login1")  // 发出 HTTP Post 请求
public String xxx(…);

@PostMapping("/login2") // 发出 HTTP Post 请求
public String yyy(…);
```

#### @RequestParam / @SpringQueryMap / @RequestBody 注解

@RequestParam / @PostMapping / @PostMapping 注解是在描述发送 HTTP 请求时所携带的参数，以及参数的格式<small>（是 JSON Sting 还是 Query String）</small>

以下面的代码示例为例：

````ad-cite
title: 示例一：@RequestParam
POST 请求中携带 Query String 格式的参数。参数的 key 值分别是 username 和 password ，参数的值是方法的实际参数值。

```java
@PostMapping("/login1")
public String xxx(@RequestParam("username") String username, 
                  @RequestParam("password") String password);
```
````

````ad-cite
title: 示例二：@SpringQueryMap
POST 请求中携带 Query String 格式的参数。参数的 key 值是参数键值对的 key ，参数的值是键值对的 value 。

```java
@PostMapping("/login2") 
public String yyy(@SpringQueryMap Map<String, Object> params); // 无脑写法一
```
````

````ad-cite
title: 示例三：@RequestBody
POST 请求中携带 JSON String 格式的参数。JSON String 的内容就是实际参数 map 转成 JSON 串的内容。

```java
@PostMapping("/login3") 
public String zzz(@RequestBody Map<String, Object> params); // 无脑写法二
```
````

#### 返回值类型

由于对方<small>（被调方的 @RestController）</small>返回的内容是一个 JSON String，所以 OpenFeign 接口的方法的返回值类型写 String 是一个 100% 不会出错的保底写法。<small>当然，可能会被项目经理骂…</small>

```java
@GetMapping("/") 
public String index();

@PostMapping("/login1")
public String xxx(…);

@PostMapping("/login2")
public String yyy(…);

@PostMapping("/login3")
public String zzz(…);
```

再高级一些的写法，你可以写成返回 Map，这种情况下 OpenFeign 会利用 jackson 将对方返回的 JSON String 转换成一个 LinkedhashMap 对象<small>（或者是 LinkedHashMap 对象的集合）</small>。

再进一步，可以写成返回 JavaBean ，前提是你要确保对方返回的 JSON String 和你这里的 JavaBean 的格式是能对的上的。

### 第 3 步：新增 OpenFeign 接口

为了接下来替换掉 RestTemplate 的"啰嗦"代码，我们这里需要自定义一个接口，并标注特定的注解：

```java
@FeignClient(name = "DepartmentFeignClient", url = "http://127.0.0.1:8080")  
public interface DepartmentFeignClient {  

    @GetMapping("/department/{id}")  
    public RestResponse<DepartmentDto> getDepartment(@PathVariable("id") Long id);  

    … 
}
```

### 第 4 步：配置 OpenFeign 功能

定义一个配置类，例如命名为 OpenFeignConfig ，在起上标注 @EnableFeignClients 注解，它的 basePackages 属性的值是 Feign 接口所在的包的包名：

```java
@Configuration  
@EnableFeignClients(basePackages = "com.example.employee.http")  
public class OpenFeignConfig {  
}
```


### 第 5 步：注入 Feign 接口，发起 HTTP 请求

暂缺


### 第 6 步：验证

略

### 其它


> [!error] @FeignClient 有 2 个注意事项
> 1.  一个服务只能被一个类绑定，不能让多个类绑定同一个远程服务；
> 2. OpenFeign 不支持多继承。

