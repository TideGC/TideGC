## 熔断和降级

熔断和降级既相关又不同，说它们相关是因为，它都是对程序中可能会抛出的异常进行处理，说它们不同是因为它们的"解题思路"完全相反：

- 降级是有一种补救：现在已经发生异常了，为了不抛出异常，赶紧执行另一段代码来作为结果返回；

- 熔断是一种预防：基于过去的"错误情况"的数量统计，提前拒绝掉调当前要执行的业务逻辑，以避免大概率可能会出现的异常。

另外降级功能不需要在 sentinel-dashboard 上做任何配置；而熔断需要<small>（因为要设置触发熔断的标准）</small>。

### 代码中的降级配置

> [!cite] 提示
> 降级是有一种出错后的补救：现在已经发生异常了，为了不抛出异常，赶紧执行另一段代码来作为结果返回。

#### 第 1 步：新增 fallback 方法

fallback 方法也叫后备方法。

为编写的 Service 代码提供一个 fallback 方法。

> [!attention] 注意事项
> 1. _fallback_ 方法的返回值必须和目标方法返回值一致；
> 2. _fallback_ 方法有 N+1 个参数，"多"出来的一个参数是 Throwable 类型的参数<small>（不能是 Exception 及其子类）</small>。<small>目标方法中抛出的异常，会通过这个参数传进 fallback 方法中。</small>

```java
public RestResponse<Department> getDepartmentBlockHandler(Long id, Throwable e) {  
    Department department = new Department(0L, "N/A", "N/A");  
    return new RestResponse<>(10086, "fall back", department);  
}
```

#### 第 2 步：启用 fallback 方法

1. 如果 controller 层的方法是目标方法，那么把"自动埋点"功能所省略下来的 **@SentinelResource** 再给补回来；
2. 如果是用 service 层方法做实验，作目标方法，那么为 Service 的某个方法添加 **@SentinelResource** 注解，为它指定 fallback 方法。

在 @SentinelResource 注解中，通过 _fallback_ 属性，指定本方法<small>（目标方法）</small>的 fallback 方法。

未来，当目标方法中抛出异常时，fallback 方法的代码会被执行。

````ad-example
title: 示例一：Controller 层使用降级
collapse: close
```java
@GetMapping("/department/{id}")  
@SentinelResource(value = "/department/{id}", fallback = "getDepartmentBlockHandler")  
public RestResponse<Department> getDepartment(@PathVariable("id") Long id) {  
    throw new RuntimeException("故意抛异常，导致请求发起方收到 500 的响应状态码");  
}
```
````

````ad-example
title: 示例二：Service 层示使用降级
collapse: close
```java
@SentinelResource(value = "doSomething", fallback = "fallbackHandler")  
public String doSomething(String username) {  
    throw new RuntimeException("故意抛出异常");  
//  return "正常返回";  
}
```
````

#### 第 3 步：验证 fallback 方法

略

#### 其它注意事项

在请求的接收方使用 Sentinel 实现降级<small>（即，Controller 抛出异常后，返回指定内容，而非原始的错误信息）</small>是和 Spring MVC 框架的全局异常处理是有重叠的。

所以，通常情况下，不太会在请求接收方处使用 Sentinel 去做降级，而是在请求发起方处利用 Sentinel 和 OpenFeign 的整合来做降级。

所以，未来，对 Sentinel 的是有会有一些惯例：

1. 请求发起方（OpenFeign +　Sentinel）作熔断，或降级；
2. 请求接收方（Spring MVC +　Sentinel）作限流。

### sentinel-dashboard 中的熔断

> [!cite] 提示
> 熔断是一种预防：基于过去的"错误情况"的数量统计，提前拒绝掉调当前要执行的业务逻辑，以避免大概率可能会出现的异常。

#### 第 1 步：新增 blockHandler 方法

> [!attention] 注意事项
> 1. _blockHandler_ 方法的返回值必须和目标方法返回值一致；
> 2. _blockHandler_ 方法的参数个数 N+1 个，"多"出来一个是 BlockException 类型参数。

```java
public Department getDepartmentBlockHandler(Long id, BlockException e) {  
    return new Department(0L, "这是 service 熔断的返回", "这是 service 熔断的返回");  
}
```

#### 第 2 步：启用 blockHandler 方法

```java
@SentinelResource(value = "getDepartmentById", 
                  blockHandler = "getDepartmentBlockHandler" // 看这里，看这里，看这里
)  
public Department getDepartmentById(Long id) {  
    System.out.println("service.getDepartmentById() 被触发执行！");  
    throw new RuntimeException("故意抛出异常");  
}
```

#### 第 3 步：sentinel-dashboard 上配置降级规则

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20221022213628.png)


#### 第 4 步：验证 blockHandler 方法

刷新页面，连续发起请求，你会发现在最初的 500 错误页面之后，你就会看到连续的 _blockHandler_ 方法的信息的返回。这就说明 _blockHandler_ 方法被触发执行了。

### 其它

#### 在 Controller 上熔断，在 Serivice 上降级

> 注意，在 sentinel-dashboard 上熔断规则是设置在 spring webmvc 自动埋点的资源上的。

这种情况下，你的熔断的"预期效果"是出不来的！原因在于：

- 尽管 Service 方法中抛出了异常，但是由于 Service 有降级处理，所以，导致 fallback 方法的执行，而你的 fallback 方法的代码逻辑又是没有抛出异常的。

- 所以，在 Web 层的 Controller 看来，它所调用的下一层方法并没有给它抛出异常，那么它给请求发起方的返回也自然就是正常的 200 返回。

- 在 Web 层正常返回情况下，Sentinel 的 "统计数据" 自然也就是没有任何问题的，那么基于 "统计数据" 的熔断自然也就无法触发执行。

所以，在反复发起请求的情况下，你始终看到的都是 Service 的降级返回，看不到 Web 层的熔断返回。

#### 同一个 Service 上同时熔断和降级

如果你在同一个 Service 的方法上使用了 fallback 和 blockHandler ，你会"同时"看到熔断和降级的效果：

- 当熔断未触发时，由于 Service 层的目标方法抛出异常，从而导致降级方法的执行，此时，HTTP 返回的就是降级方法返回；
- 当熔断发生时，熔断方法被触发执行，此时，HTTP 返回的就是熔断方法返回。

```java
@SentinelResource(value = "doSomething", blockHandler = "blockHandler", fallback = "fallbackHandler")  
public String doSomething(String username) {  
    throw new IllegalArgumentException("故意抛出异常");  
//  return "正常返回";  
}  
  
// 注意：会"多"出来一个 Throwable 类型的异常参数变量  
public String fallbackHandler(String username, Throwable e) {  
    log.info("{}, {}", username, e.getClass().getName());  
    log.info("index: 这是一个\"备胎\"方法");  
    return "非正常返回：这是一个\"备胎\"方法";  
}  
  
// 注意：会"多"出来一个 BlockException 类型的异常参数变量  
public String blockHandler(String username, BlockException e) {  
    log.info("{}", username);  
    log.info("index: 这是一个\"拦路虎\"方法");  
    return "非正常返回：这是一个\"拦路虎\"方法";  
}
```


### 外置类

> 下面是以降级方法为例，熔断方法同样适用。

在 `基本使用` 的示例中，后备方法是直接写在 Controller 中的，为了避免 Controller 中的代码越来越臃肿，我们可以把后备方法处理到一个独立的类中。

```java
@Component
public class DemoControllerFallback {

    public static String indexFallback(String username, Throwable e) {
        System.out.println(e.getMessage());
        return "后备方法：对接口的访问被降级了！";
    }

}
```

后备有 3 点注意的地方：

1. 后备类应该是一个被 Spring IoC 容器托管的单例对象：**@Component** 。
2. 后备方法必须是一个静态方法：**static** 。
3. 后备方法的参数数量仍然必须是 N + 1 。

有了后备类之后，我们的 Controller 中的 @SentinelResource 注解就要变动成如下：

```java
@RequestMapping("/")
@SentinelResource(
    fallbackClass = DemoControllerFallback.class,   // 看这里，看这里，看这里
    fallback = "indexFallback"
)
public String index(@RequestParam(name = "username", required = false) String username) {
    throw new RuntimeException();
}
```

> [!tip] 说明
> 如果你的代码中同时有后备类、后备方法，是后备类的代码生效，后备类的代码被触发执行。

> [!danger] 降级的响应状态码
> 在没有使用 Sentinel 降级功能时，Spring MVC 的 HTTP 返回是 500<small>（因为 Controller 抛出了异常）</small>。而在使用了 fallback 方法后，Spring MVC 的 HTTP 返回的则是 200 ，理论上，本次请求收到的就是一个成功响应。
