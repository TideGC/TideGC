---
alias: 线程的调度
---

## 线程的调度

### 1. 实现线程调度的方法

线程调度的实现核心思路只有一个：**通过各种手段，迫使当前线程（即，Running 线程）进入 Blocked/Runnable 状态，让出 CPU , 从而让其它线程拥有执行机会**。

-   手段一：**Thread#join** 方法

    Thread#join 方法会导致当前线程阻塞<small>（让出 CPU）</small>，等待调用该方法的线程<small>（即，Thread 对象所代表的那个线程）</small>结束后再继续执行本线程。

-   手段二：**Thread.sleep** 方法

    Thread.sleep 方法会导致当前线程睡眠<small>（本质上也是阻塞，迫使当前线程让出 CPU）</small>，在指定时间到期后，重新进入可运行状态。

-   手段三：**Thread.yield** 方法

    Thread.yield 方法稍微有点不同，它让当前线程让出 CPU ，但并不是进入阻塞状态，而是直接进入 Runnable 状态。

需要注意的是，当前线程让出 CPU 之后，接下来是哪个线程执行<small>（从 Runnable 状态变为 Running 状态）</small>带有『**不确定性**』。


### 2. 线程的同步与互斥

当两个或多个线程需要访问同一资源<small>（或执行同一段代码时）</small>，需要某一时刻只能被一个线程使用的方式，称为线程『**互斥**』。

当两个或多个线程以互斥的方式访问完同一资源<small>（或执行同一段代码）</small>后，『通知』其他线程的方式，称为线程『**同步**』。

> 同步与互斥通常总是一起出现的。只出现互斥，不出现同步，意味着代码逻辑是一种极简单的多线程状况。


### 3. synchronized 关键字

使用 **synchronized** 关键字修饰的方法控制对类成员变量的访问。每个类实例都对应一把锁，方法一旦执行，就独占该锁，直到方法结束时才将锁释放；此后其它被阻塞的线程才能获得该锁，重新进入可执行状态。

这种机制保证了同一时刻，对于每一个实例，其所声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。

语法：

```java
访问修饰符 synchronized 返回类型 方法名 () {
    …
} 
```

或 

```java
synchronized 访问修饰符 返回类型 方法名 () {
    …
} 
```

synchronized 方法的缺陷在于：如果将一个耗时的方法声明为 synchronized 将会使其它线程阻塞时间过长，从而影响系统执行效率和用户体验。

同步代码块是同步方法的缺陷的解决方案，它『锁住』的不是整个方法，而是方法中的一个代码片段。

语法：

```java
synchronized (一个对象) {
    …
}
```

这里的『一个对象』通常是一个字符串常量对象。

