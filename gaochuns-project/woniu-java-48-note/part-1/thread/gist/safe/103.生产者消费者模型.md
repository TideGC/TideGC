# 生产者消费者模型

> [!tip]
> 这里的生产者消费者模型是最简单的模型：一个生产者、一个消费者、仓库容量 1 。

## 1. monitor 对象版 

在 Java 的世界中，所有的对象都可以做「锁对象」。

> [!attention] 注意
> 这里的「锁对象」是广义上的锁对象，并非单指 Lock 对象。

用到的单词是 Monitor ，也叫检测对象。

但是对锁<small>（Monitor）</small>对象的使用，有一个特殊要求<small>（其实也是有原因的）</small>：在调用 Monitor 对象的 wait、signal 方法的调用必须在同步代码块（synchronized）中。

````ad-cite
title: 代码

```java
// 定义两个字符串常量充当锁（monitor）对象
private static final String canRead = "can read";
private static final String canWrite = "can write";

public static void main(String[] args) {

    // 消费者线程，执行读操作。从「仓库」中取走数据。
    Thread reader = new Thread(() -> {
        try {
            for (int i = 0; i < 26; i++) {

                synchronized (canRead) {
                    if (box == null)
                        canRead.wait(); // 当前线程阻塞在 canRead monitor 对象上 。
                }

                System.out.printf("%c ", box);
                box = null;

                synchronized (canWrite) {
                    canWrite.notify();  // 唤醒阻塞在 canWrite monitor 对象上的任一线程 。
                }
            }
            System.out.println();

        } catch (Exception e) {
            e.printStackTrace();
        }
    });

    // 生产者线程，执行写操作。向「仓库」中存放数据。
    Thread write = new Thread(() -> {
        for (char c = 'a'; c <= 'z'; c++) {
            try {
                synchronized (canWrite) {
                    if (box != null)
                        canWrite.wait();  // 当前线程阻塞在 canWrite monitor 对象上
                }

                box = c;
                synchronized (canRead) {
                    canRead.notify(); // 唤醒阻塞在 canRead monitor 对象上的任一线程
                }
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    });

    reader.start();
    write.start();
}
```
````

## 2. 条件变量版本 

条件（Condition）变量是操作系统原理中的概念。各种操作系统都支持、实现了条件变量。作为虚拟机，JVM 也不例外。

条件变量和上面的锁（monitor）对象一样，都能造成当前线程的阻塞，造成「当前线程阻塞在 xxx 条件变量上」的情况，并且，同样也可以做到「唤醒阻塞在 xxx 条件变量上的线程」。

条件变量有一个特殊性：它来源于一个锁（Lock）对象。你要通过一个 Lock 对象来获得一个或多个条件变量，并且，你在操作条件变量之前，必须要先获得派生出它的那个 Lock 对象。

````ad-cite
title: 代码

```java
public static Lock synchronizedLock = new ReentrantLock();   // 用来「派生」条件变量的锁对象

// 条件（condition）变量来自于锁。
public static Condition canRead = synchronizedLock.newCondition();
public static Condition canWrite = synchronizedLock.newCondition();

public static void main(String[] args) {

    // 生产者线程。
    Thread writer = new Thread(() -> {
        for (char c = 'a'; c <= 'z'; c++) {
            try {
                synchronizedLock.lock();    // 获得派生出条件变量的那个锁对象。

                if (box != null)
                    canWrite.await();       // 当前线程阻塞在 canWrite 条件变量上

                box = c;
                canRead.signal();           // 唤醒阻塞在 canRead 条件变量上的线程
                synchronizedLock.unlock();  // 释放派生出条件变量的那个锁对象。
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });

    Thread reader = new Thread(() -> {
        try {
            for (int i = 0; i < 26; i++) {
                synchronizedLock.lock();    // 获得派生出条件变量的那个锁对象。
                if (box == null)
                    canRead.await();        // 当前线程阻塞在 canRead 条件变量上

                System.out.printf("%c ", box);
                box = null;
                canWrite.signal();          // 唤醒阻塞在 canWrite 条件变量上的任一线程
                synchronizedLock.unlock();  // 释放派生出条件变量的那个锁对象。
            }

            System.out.println();

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });

    writer.start();
    reader.start();

}
```
````


## 3. 信号量版本 

信号量（Semaphore）也是操作系统原理中的概念。各种操作系统都支持、实现了条件变量。作为虚拟机，JVM 也不例外。

在使用经验上：信号量（背后的那个数字）代表的是资源数量。

- 生产者：需要的资源是「坑位」。 生产过程会导致「坑位数 - 1」，但是同时会导致「商品数 + 1」；
- 消费者：需要的资源是「商品」。 消费过程会导致「商品数 - 1」，但是同时会导致「坑位数 + 1」。

对信号量做减法，如果不够减（结果为负），会导致当前线程的阻塞；一直阻塞到够减，才会做这个减法，然后继续执行。

````ad-cite
title: 代码

```java
public static Semaphore productNum  = new Semaphore(0); // 初始状态，商品数为 0
public static Semaphore pitNum      = new Semaphore(1); // 初始状态，坑位数为 1

public static void main(String[] args) {

    Thread reader = new Thread(() -> {

        try {
            for (int i = 0; i < 26; i++) {
                    productNum.acquire();   // productNum - 1
                    System.out.printf("%c ", box);
                    pitNum.release(1);  // pitNum + 1
            }

            System.out.println();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });

    Thread write = new Thread(() -> {

        for (char c = 'a'; c <= 'z'; c++) {
            try {
                pitNum.acquire();   // pitNum - 1
                box = c;
                productNum.release(1);  // productNum + 1
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });

    reader.start();
    write.start();
}
```
````



