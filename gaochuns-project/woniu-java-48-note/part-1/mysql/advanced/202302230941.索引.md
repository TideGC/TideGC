---
alias:
- 索引
---

我们通常在使用 MySQL<small>（特别是 InnoDB 引擎时）</small>，会涉及到的索引主要有**单列索引**<small>（其中包括普通索引、唯一索引、主键索引）</small>和**组合索引**。另外，鼎鼎有名的全文索引 InnoDB 引擎不支持，只能在 MyISAM 引擎中使用<small>（类似的还有空间索引）</small>。

## 各种索引

### 普通索引

MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，普通索引的建立纯粹为了查询数据更快一点。

> 哪怕是有回表查询，通过普通索引查也比全表扫描快的多得多的多。

创建普通索引，可以在建表时使用 _index_ 或 _key_ 关键字：


```sql
-- SQL 语句
CREATE TABLE department
(
  `id`       BIGINT AUTO_INCREMENT COMMENT '部门ID',
  `name`     VARCHAR(15) COMMENT '部门名称',
  `location` VARCHAR(13) COMMENT '部门所在地',
  INDEX(name),
  PRIMARY KEY (`id`)
) COMMENT '部门信息表';
```


### 唯一索引

唯一索引在普通索引的基础上多了一个要求：索引列中的值必须是唯一的。

创建唯一索引，可以在建表时使用 _UNIQUE INDEX_ 关键字：

```sql
-- SQL 语句
CREATE TABLE department
(  
  `id`       BIGINT AUTO_INCREMENT COMMENT '部门ID',  
  `name`     VARCHAR(15) COMMENT '部门名称',  
  `location` VARCHAR(13) COMMENT '部门所在地',  
  UNIQUE INDEX (name),  
  PRIMARY KEY (`id`)  
) COMMENT '部门信息表';
```


唯一索引有一个反常识的地方：它允许为空值，在唯一索引标识的字段中可以出现多个 NULL 。


### 主键索引

主键索引是大家很熟悉的索引了，它要求非空且唯一。

创建唯一索引，可以在建表时使用 _PRIMARY KEY_ 关键字。

主键索引也被称为一级索引，它的特殊性在于一张表中一定会有主键索引，即便你没有指定！

## 其它的索引分类

### 一级索引和二级索引

有时候你会听到、看到一级索引和二级索引的概念。这不是新的索引，而是另一套叫法。

在有的书籍和资料中，会将普通索引称作二级索引，与之对应的是将主键索引叫做一级索引。

于此同时，唯一索引就被称作唯一二级索引。

### 聚簇索引

聚簇索引<small>（和非聚簇索引）</small>也不是另一种新的索引，而是概念。

简单来说，一张数据库表有且仅有一个聚簇索引，而非聚簇索引可以有多个。通常主键索引就是聚簇索引。

聚簇索引的特殊之处在于：表中的数据在磁盘上的先后排布顺序，和聚簇索引中的索引顺序是一致的。

简单来说，表中的数据在磁盘上的位置，id=1 和 id=2 的两条数据一定是紧挨着的，且有序的，即，id=2的一定是在 id=1和id=3 的中间，而 id=3 又一定是在 id=2 和 id=4 的中间的。


### 存储索引

有时你会听到存储索引的概念，在这个概念下有 B+ 树索引和 Hash 索引。

此索引非彼索引。这里的索引换个说法指的是数据库引擎的数据存储结构。InnoDB 引擎支持以 B+ 树的方式和 Hash 的方式去“组织”磁盘上的数据。

## 索引和 B+ 树

每当你创建一个索引时，InnoDB 引擎就会在磁盘上创建一个棵 B+ 树。

下图就是对表的 *name* 字段创建索引后，InnoDB 所创建的一颗 B+ 树<small>（这个图画的有一点点问题，但是问题不大）</small>。

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220706094000.png)

> [!attention] 注意
在索引树的叶子节点所指向的磁盘上的一个 Page 中，记录的是 id 和索引列的数据。这是对应数据库中的一条记录的“不完整”记录。
> 
> 另外，索引 B+ 树的叶子节点<small>（Page）</small>还会记录“完整”的表中数据在磁盘上的哪个 Page 上。

如果你使用了联合索引，那么索引树的叶子节点<small>（Page）</small>中记录的树就会都一点点。

下图就是对表的 name、age 和 sex 创建联合索引之后，InnoDB 所创建的 B+ 树。

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/java/hemiao/20220706102432.png)


## 回表查询和覆盖索引

在上一章节中，我们看到，当你为表的某列创建索引之后，InnoDB 引擎所创建的索引 B+ 树的叶子节点<small>（Page）</small>中记录了表中数据的不完整信息<small>（id + 索引列数据）</small>，以及完整信息所在磁盘的 Page 地址。

如果，你执行的是 _select *_ 这样的查询，导致在索引 B+ 树中拿不到你所要的全部的数据，那么 MySQL 需要再做一次查询，根据索引叶子节点中所记录的完整的数据的所在位置，再做一次磁盘 IO 操作，去拿完整的数据。这个过程就叫回表查询。

如果，你执行的碰巧就是 _select id, name_ 这样的查询，在索引 B+ 树<small>（的叶子节点中）</small>中正好有你想要查询的这部分字段信息，那么 MySQL 就没有必要再去查找完整的信息了。这个过程就叫覆盖索引。


## 索引的创建和使用原则

### 索引并不是越多越好

索引的创建和使用体现了 2 个性能提升准则:
- 空间换时间；
- 牺牲写操作，提升读操作。
 
因此，索引越多，磁盘空间占用越大，写操作速度越慢。所以，有多少索引字段，是一个需要权衡的问题，不是无脑加加加。

### 避免更新聚簇索引数据列

考虑到聚簇索引通常就是主键索引，所以这个准则也就是说不要去改动数据的 ID 。

聚簇索引直接影响着数据在磁盘上的排布顺序，你改动了数据的主键 ID，那么就意味着在磁盘上这条数据要位置，这就带来了额外的磁盘 IO 操作。

> 这也是为什么通常会用一个额外的，无业务逻辑的、独立的、唯一列作为主键列。

### 经常更新的表就避免对其进行过多的索引

前面提到过，索引是牺牲写操作时间来换取读操作时间的提升。考虑到大多数情况下读写操作的频次比例有很大的悬殊，所以通常这种牺牲是值得的。

但是，万一有个写操作功能是很频繁的，那么就不要牺牲它了。

### 数据量小的表最好不要使用索引

如果一张表的数据量不大，几千、几万的级别，那么进行全表扫描和通过索引查找之间可能根本就没有太大的区别。

### 避免在不同值少的列上加索引

因为这种情况下，索引会失效。

比如，你对『性别』列加索引，但是这一列的值的可能最多也就只有两三种。回头你在 SQL 语句中用性别作为条件查询，MySQL 真正执行的时候也不会去使用性别索引。

在经常做为查询条件的，且区别度大的列/字段上建索引：身份证号、电话号、家庭地址 … 。

### 根据业务需求建立索引

不要凭空想象去添加索引，要根据你的 SQL 语句中使用到了哪些字段作为查询条件来创建索引。



