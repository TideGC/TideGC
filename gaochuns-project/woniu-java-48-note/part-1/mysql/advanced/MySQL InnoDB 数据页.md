## 1. InnoDB 数据页的大小

在 MySQL<small>（的 InnoDB 引擎）</small>层面，操作的最小单位是"**页**"，一个页的大小是 16k 。

在 MySQL 中，你可以通过下述命令查看到 InnoDB 引擎的 page 大小：

``` sql
show variables like 'innodb_page_size';
```

你可以很明显看到是 16384 字节，也就是 16k 。

假设在 MySQL 的表中，每一条数据占 1k 大小，那么在 InnoDB 引擎中，每一页中就会有 16 条数据。<small>（实际上并没有这么多，一页中存不下 16 个 1k 大小的数据）</small>。

这也就意味着，在上述假设下，即便你是通过 id 这样有唯一性的条件在「查询一条」数据，但是实际上，MySQL 从磁盘上读出来的总是 16 条数据，然后，在内存中进行筛选、过滤，返回「那一条」数据给你。

## 2. InnoDB 数据页结构

一个数据页的 16K 大小的空间除了存储用户 insert 进来的数据之外，还需要存储一些 MySQL 自身所需要的一些数据。

一个数据页的存储空间大致被划分为 7 个部分：

| 名称                    | 中文名                      | 占用空间大小  | 
| :---------------------- | :-------------------------- | :------------ |
| File Header             | 文件头部                    | 38 byte       | 
| Page Header             | 页面头部                    | 56 byte       |
| **Infimum + SupreMum**  | 页面中的最小记录和最大记录  | 26 byte       | 
| **User Records**        | 用户记录                    | 不确定        | 
| Free Space              | 空闲空间                    | 不确定        |
| **Page Directory**      | 页目录                      | 不确定        | 
| File Trailer            | 文件尾部                    | 8 byte        | 

用户 insert 进 MySQL 的数据就存放在数据页的 **User Records** 区域中。另外，数据页中天生、天然有两条记录：InfiMum 和 SupreMum 。<small>它们的作用类似于数据结构中的有头循环列表中的头节点的作用，多开销一些磁盘和内存空间，但是能方便 MySQL 对数据的管理。</small>

从逻辑结构上来看，用户 insert 进 MySQL 中的数据总是「夹在」Infimum 和 SupreMum 中间的。也就是说，MySQL 故意做出了如下规定：Infimum 总是一个数据页中的第一条数据，SupreMum 总是一个数据页中的最后一条数据。

> [!info] 提示
> 从上帝视角看，你第一次 insert 到数据页中的数据，实际上在数据页中是第二条数据，然后它后面还有一条数据。

## 3. Page Directory 和槽

MySQL 会将数据页中的数据分成若干个组。初始是 2 个组，其中 Infimum 是第一个组，且它是第一个组中唯一的数据；SupreMum 是第二个组。未来，你向 MySQL 中 insert 的数据会被划分到第二个组中。

MySQL 还会专门去记录每一个组的最后一条记录的位置，并存储在特定区域，这个区域就是 Page Directory 。

> [!info] 提示
> 在逻辑上，你可以把 Page Directory 理解成一个数组，其中的每一个单元记录的都是一个组中的最后一条数据的地址。这每一个单元就被称作槽，下标索引从 0 开始。

- 每一个组的第一条数据，就是上一个组的最后一条数据的下一条数据。你可以从槽中获得上一个组的最后一条数据的位置；
- 每一个组的最后一条数据就记录在当前组对应的槽中。

MySQL 规定：

- 对于 Infimum 所在的组<small>（即，第一个组）</small>，只能有 1 条记录；
- 对于 Supremum 所在的组<small>（即，最后一个组）</small>，只能有 1 ~ 8 条记录；
- 对于其它组<small>（即，中间组）</small>，只能由 4 ~ 8 条记录。


## 3. 页的数量

因为 MySQL 是根据 B+ 树建立的索引，因此，一个 MySQL 的表中能存储多少条数据取决于叶子节点的数量，与非叶子节点<small>（根节点和中间节点）</small>无关。

假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。也就是说，由 bigint 和磁盘地址所组成的键值对占 14 字节的空间。

### 假设 B+ 树的深度为 2

因为 B+ 树的深度为 2 ，那么意味着其它节点都是叶子页。那么，根节点中能记录的叶子节有：`16384 / 14 = 1170` 个。即，最多可以有 `1170` 个 Page 来存储数据。

而假设表中的每条数据占 1k 大小，上面计算过，每 1 个 Page 中可以有 16 条数据，那么 1170 个页中，总共最多可以有 `1170 x 16 = 18720` 条数据，大约 18 万条<small>（不到 19 万条）</small>。


### 假设 B+ 树的深度为 3

因为 B+ 树的深度为 3 ，那么意味着它的第二层都是中间节点。那么，根节点中能记录的中间节点有：`16384 / 14 = 1170` 个。同样，每个根节点中记录的叶子节点又有 `1170` 个，那么深度为 3 的 B+ 树总共会有 `1170 x 1170 = 1368900` 个叶子节点。

而假设表中的每条数据占 1k 大小，上面计算过，每 1 个 Page 中可以有 16 条数据，那么 1368900 个页中，总共最多可以有 `1368900 x 16 = 21902400` 条数据，大约 2100 万条<small>（不到 2200 万条）</small>。

这也是通常所说的，MySQL 单表数据量到千万是个「坎」的原因。因为再多，B+ 树的层次会再多加一层，这就意味着查询操作的时间会增加。

另外，上述的数据量都是基于，每条数据占 1k 大小的假设算出来的，如果单条数据占用空间更大或更小，那么上述算出来的结果就会有波动。

### 行数据有多长

上述的例子中，我们始终假设表的每 1 行数据长度为 1k ，而在 MySQL 可以通过如下命令查询到表的行数据平均长度：

``` sql
mysql> SHOW TABLE STATUS LIKE 'employee';
```

上述 SQL 在查询 `emloyee` 表的相关信息，其中，有一项为 `Avg_row_length` ，它的值就是 employee 表的行数据平均长度。



