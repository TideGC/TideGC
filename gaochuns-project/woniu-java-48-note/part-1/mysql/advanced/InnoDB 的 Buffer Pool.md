---
alias:
- InnoDB 的 Buffer Pool
---

## InnoDB 的 Buffer Pool

InnoDB 存储引擎在处理客户端的请求时，如果需要访问某个页的数据，就会把完整的页中的数据全部加载到内存中。也就是说，即使只需要访问一个页的一条数据，也需要先把整个页的数据加载到内存中。

将整个页加载到内存中后，就可以进行读写访问了，而且在读写访问之后并不着急把该页对应的内容空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页时，就可以省下磁盘 I/O 的开销了。

### Buffer Pool

为了缓存磁盘中的页，MySQL 服务器启动时就像操作系统申请了一大片连续的内存空间<small>（Buffer Pool）</small>。

默认情况下，Buffer Pool 的大小是 128 MB 。你可以在启动 MySQL Server 时配置 innodb_buffer_pool_size 启动项来重置这个值：

```txt
[myqld]
innodb_buffer_pool_size = 268435456
```

Buffer Pool 的大小也不能太小，最小为 5MB 。当你指定一个小于 5MB 的值时，MySQL Server 会自动设置成 5MB ，即，5MB 保底。

Buffer Pool 也被划分为若干页面，页面大小与 InnoDB 表空间使用的页面大小一致<small>（默认时 16 KB）</small>。

> [!cite] 提示
> 为了与磁盘中的页面区分开，Buffer Pool 中的页面也被称作缓冲页。

### Free 链表和 LRU 链表

刚刚完成初始化的 Buffer Pool 中，所有的缓冲页都是空闲的，所以，每一个缓冲页都会被加入到一条名为 free 的链表中。

每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 free 链中去一个空闲的缓冲页，然后将该缓冲页从链表中移除，表示该缓冲页已经被使用了。

Buffer Pool 对应的内存大小毕竟是有限的，当 free 链上已经没有多余的空闲的缓冲页使用时，Buffer Pool 就会把某些旧的缓冲页从 Buffer Pool 中移除，然后再把新的页放进来。

为了解决哪些缓冲页该被移除的问题，Buffer Pool 建立了一条 LRU 链，基于最近最少使用的原则去淘汰缓冲页。

当需要访问某个页时，Buffer Pool 会按照下面的方式处理 LRU 链表：

- 如果该页不在 Buffer Pool 中，就把该页从磁盘加载到 Buffer Pool 缓冲页中，并把它加塞到 LRU 链表的头部；

- 如果该页已经加载到 Buffer Pool 中，就直接把它移动到  LRU 链表的头部。

> [!cite] 提示
> 实际上 Buffer Pool 对 LRU 链有进一步的优化，它将 LRU 链分成了 young 区域和 old 区域来优化一些极端情况下导致的 LRU 淘汰策略「不科学」的情况。


### 脏页的刷新

如果我们修改了 Buffer Pool 中某个缓存页的数据，它就与磁盘上的页不一致了，这样的缓冲页也被称为脏页<small>（dirty page）</small>。

Buffer Pool 中也有一条专门的链用来"串联"其所有的脏页：flush 链。

虽然可以，但是为了提升效率，InnoDB 存储引擎并未在修改完某个缓冲页之后，立即将其刷新到磁盘中的对应页上，而是有一个专门的后台线程负责每隔一段时间就把<small>（截至目前为止的）</small>所有脏页书信到磁盘，这样可以不影响用户线程处理正常的请求。

简而言之就是，脏页并不是立即刷新的，而是加入到了 flush 链中，待之后的某个时刻再刷新到磁盘中。

### 脏页的刷新时机

1. 磁盘上的 redo log 日志文件写满时。因为 redo log 的大小是固定的，所以当 redo-log 写完后会循环覆盖写入，为了避免覆盖导致数据丢失，相关脏页会被 flush 到磁盘。
2. 内存不足需要淘汰数据页。如果淘汰的是脏页，则需要将这些脏页刷盘。
3. 系统空闲的时候后台会定期 flush 适量的脏页到磁盘。
4. MySQL Server 正常关闭时，会把所有脏页都flush到磁盘。

前两种情况过于频繁会降低 MySQL Server 的性能，第三种系统空闲所有不会有性能问题。第四种要关闭自然也不用考虑性能问题。