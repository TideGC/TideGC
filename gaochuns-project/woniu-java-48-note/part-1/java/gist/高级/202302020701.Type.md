---
alias: 'Java 的类型（Type）体系'
---

## Java 的类型（Type）体系

### 1. Type 体系的历史 

> [!info] 提示
> 实际上，是先后 Class，而后有 Type 。也就是说，一开始 Java 并没有 “**类型体系**” 这样的概念。
> 
> 是因为引入了泛型概念之后，为了将泛型概念引入 Java，并作出向后兼容，从而为 Class “**补**”了一个 Type 祖先和其它兄弟， 从而完善了整个体系。

在早期的 Java<small>（5.0 之前）</small>中所有的类型都有一个 Class 对象，包括基本类型和自定义类型：

```java
Student.class
Teacher.class
String.class
Integer.class
Double.class
Boolean.class
int.class
int[].class
double.class
double[].class
boolean.class
boolean[].class
…
```

Class 对象中包含了当前类型的定义信息，**它是 Java 反射的基础**。通过一个类型的 Class 对象，你可以查询得到这个类型有哪些域<small>（Field）</small>，哪些方法<small>（Method）</small>，哪些构造器<small>（Constructor）</small>等信息。

但是，在 JDK 5.0 引入泛型概念之后，Java 官方发现，新引入的泛型相关的一些类型，它们**不适用**上面我们所说的“**所有的类型都有一个 Class 对象**”这句话。

这些泛型相关的类型的“那个对象”，不能归类于是 Class 对象这个概念之下。它们的“那个对象”既和 Class 对象有相似的地方，又和 Class 对象有所区别。

对此，Java 官方抽取了它们和 Class 的相同点，提炼出 Type 概念，并补全了其它的类型：

```txt
Type
├── Class
├── ParameterizedType
├── TypeVariable
├── WildcardType
└── GenericArrayType
```

Type 和它的子接口、实现类<small>（Class、ParameterizedType、TypeVariable、WildcardType、GenericArrayType）</small>共同组成了 Java 的类型体系。

现在：

- 所有和泛型没有半毛钱关系的类型，都有一个 Class 类型的对象与之对应。例如，String 类型、String[] 类型。
- 所有和泛型沾边的类型，根据其具体情况，都有一个 Type 类型的子类型的对象与之对应。例如，List\<String\> 类型、T[] 类型。

这里有一个比较典型的示例：

- String[] 类型的类型对象是 Class；
- List\<String\> 类型的类型对象是 Type 类型的子类型 ParameterizedType；
- List\<String\>[] 类型的类型对象是 Type 类型的子类型 GenericArrayType。

### 自定义工具方法

为了更方便地检测 Type 的具体类型，我们可以准备一个如下的简单的方法：

```java
public static String getTypeName(Type type) {
    if (type instanceof Class)
        return "Class";             // just like "String"
    else if (type instanceof TypeVariable)
        return "TypeVariable";      // just like "T"
    else if (type instanceof ParameterizedType)
        return "ParameterizedType"; // just like "List<String>";
    else if (type instanceof GenericArrayType)
        return "GenericArrayType";  // just like "T[]";
    else
        return "something wrong";   // 理论上不该如此
}

```

### 2. 各种 Type 

[[202302031200.Type|各种 Type 类型]]



#### 新类型的新方法

##### ParameterizedType 的 getActualTypeArguments

Class 的 getGenericSuperclass 方法返回的是泛型父类，它的类型是 Type 。

实际上通过 instanceof 运算符，我们可以判断出泛型父类的实际信息是 ParameterizedType 类型。

而 ParameterizedType 类型有一个 getActualTypeArguments 方法，它能返回泛型父类的所使用的泛型参数。

```java
ParameterizedType superclass = (ParameterizedType) StringLinkedList.class.getGenericSuperclass();
for (Type cur : superclass.getActualTypeArguments()) {
    System.out.println(cur);    // 这个例子中只有一个：String
}
```

