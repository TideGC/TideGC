---
alias: 位操作
---

## 位操作

开始本章之前请先阅读[[202211161808.二进制与十进制|《二进制和十进制》]]笔记。

### 1. 二进制位操作

#### 1.1 输出数字的二进制形式

在 Java<small>（ 和很多语言中 ）</small>没有办法输出一个整数的二进制形式，因为太罗嗦了，没必要也没有实际价值。

但是有输出成十六进制进行显示的方式。在 Java 中可以使用 springf 结合 `%x` 占位符进行输出展示：

```java
int i = ...;
System.out.printf("%x", i); // 需要注意的是 printf 没有自动换行。
```

当你拿到一个数字的十六进制的『书写方式』之后，你可以自己手动 `1:4` 地转换出它的二进制的书写方式。


#### 1.2 按位与运算和按位或运算

> `按位与` 和 `按位或` 运算都是站在二进制角度进行的运算。

按位与运算使用运算符 `&` ，按位或运算使用运算符 `|` 。

逻辑与<small>（ && ）</small>操作就引申自按位与<small>（ & ）</small>操作。按位与操作的运算规则为：

```
  1 1 0 0
& 1 0 1 0
----------
  1 0 0 0 
```

即，只有参与运算的两个操作数均为 1 时，其运算结果为 1 ，否则就为 0 。

你可以使用下列代码进行验证：

```java
System.out.printf("%x", 0xc & 0xa);
```

逻辑或<small>（ || ）</small>操作就引申自按位或<small>（ | ）</small>操作。按位或操作的运算规则为：

```
  1 1 0 0 
| 1 0 1 0
----------
  1 1 1 0 
```

即，只有参与运算的两个操作数均为 0 时，其运算结果为 0 ，否则就为 1 。

```java
System.out.printf("%x", 0xc | 0xa);
```

#### 1.3 按位左移和右移运算

> `按位左移` 和 `按位右移` 运算都是站在二进制角度进行的运算。

按位左移的运算规则：每一位均向高位移动，高位溢出，低位补零。

```
    1 1 0 0 
<<        1
------------
[1] 1 0 0 0      
```

上面的 `[1]` 是溢出、被忽略掉的那个。

按位右移的运算规则：每一位均向低位移动，低位移除，高位补零或补一取决于符号位。

```
    1  1  0  0 
>>           1  
---------------
   [1] 1  1  0
```

上面的 `[1]` 是补位、补进来的那个。之所以补 1 而不是补 0 ，是因为原来的最高位<small>（ 即，符号位 ）</small>的值就是 1 。

2 个小细节：

1. 在左移<small>（ << ）</small>过程中，数字可能会从正变负，也可能从负变正。<small>因为，符号位的值被「顶出去」了，而次高位的值变成了符号位的值，而次高位的值有可能是 0，也有可能是 1 。</small>

2. 在右移<small>（ >> ）</small>过程中，虽然值在变，但是正数始终是正数、负数始终是负数。<small>因为，在右移过程中，高位的补位始终和之前的符号位一致，所以以前是 0 那么就是补 0 ，以前是 1 那么就是补 1 ，因此，符号位的值始终没变。</small>


#### 1.4 按位取反操作

> `按位取反` 运算都是站在二进制角度进行的运算。

按位取反<small>（ ~ ）</small>运算的逻辑非常简单、直接：整数的二进制形式的每一位进行 0 变 1、1 变 0 操作。

```
~ 1  1  0  0 
---------------
  0  0  1  1
```

#### 1.5 按位异或操作

暂时没用上<small>（ 大多数情况下也用不上 ）</small>，略。

### 2. 为什么负数是整数取反加一

一个负数的二进制长什么样？它的整数的二进制形式进行 `取反` 再 `加一` 。例如：

```
00000000 00000000 00000000 00000100 // 这是 4 
11111111 11111111 11111111 11111011 // 这是 4 取反
11111111 11111111 11111111 11111100 // 这是 4 取反加一
```

以 `-4` 为例，-4 在 4 的基础上进行 `取反` 再 `加一` 的操作后，最后的结果，就是 -4 的二进制的样子。

一个负数的二进制形式，是其正数<small>（ 即，绝对值 ）</small>的 `取反加一` 这个规则是怎么来的？`取反加一` 是计算一个负数的二进制形式的快捷方式，或者说是一个计算口诀，而非定义。

一个负数的二进制应该『长』什么样？我们从另一个角度来分析、来推导：`-4` 长啥样我们暂且不知道，但是我们可以 100% 确定的是 `-4 + 4` 一定是等于零的！那么，我们考虑一下 4 <small>（ 的二进制 ）</small>要加上一个什么样的二进制数能得到零？

```
  00000000 00000000 00000000 00000100  // 这是 4
+ ???????? ???????? ???????? ????????
----------------------------------------------------------
  00000000 00000000 00000000 00000000  // 这是 0
```

这里很显然有一个伤脑经的问题：`4` 的二进制『书写方式』中已经出现了 1 ，接下来还要再做一个加法，这个 1 是无论如何加『加』不掉的，而且毫无以为，1 只会越加越多，没有越加越少的道理。

怎么办？计算机的办法是，估计『**造进位**』，把 1 从高位顶出去。


```
    00000000 00000000 00000000 00000100  // 这是 4
  + 11111111 11111111 11111111 11111100  // 这一定就是 -4 
----------------------------------------------------------
[1] 00000000 00000000 00000000 00000000  // 这是 0
```

从 `4 加 -4 必须的 0` 这个基本原理可知，-4 的二进制只有可能是上面这个样子才能满足这个数学公里，而 -4 的这个样子，刚好就是 4 取反加一的样子。


### 3. 位操作惯例和技巧

#### 3.1 置 1 和清 0

置 1 操作依赖于位或（ `|` ）操作：

-    x | 1 == 1
-    x | 0 == x

```java
/**
 * 将参数 val 的 pos 位置 1 。
 * pos 从 0 开始计数。
 */
public static long setBit(long val, int pos) {
    return val | (1L << pos);
}
```

清 0 操作依赖于位与（ `&` ）操作：

-    x & 1 == x
-    x & 0 == 0

```java
/**
 * 将参数 val 的 pos 位清 0 。
 * pos 从 0 开始计数。
 */
public static long clrBit(long val, int pos) {
    return val & ~(1L << pos);
}
```


#### 3.2 位操作拼接成数字

假设在规划中，我们会将一个 long  的 63 位<small>（ 不包括、不使用符号位 ）</small>分为 3 部分，从低位到高位分别为 c、b、a，分别用占 x、y 和 z 位<small>（ 逻辑上，x + y + z == 63 ）</small>

```java
long cBits = x;
long cShift = 0L;

long bBits = y;
long bShift = cBits;

long aBits = z;
long aShift = bBits + cBits;

long c = ...;
long b = ...;
long a = ...;

long result = (a << aShift) 
    | (b << bShift)
    | (c << cShift);
```

另外，如果需要做取值范围的合法性校验的话，你可能会用得上下列 3 个变量：

```java
long cMax = ~(-1L << cBits); // cMax 取值范围应该在 [0, cMax] 之间
long bMax = ~(-1L << bBits); // bMax 取值范围应该在 [0, bMax] 之间
long aMax = ~(-1L << aBits); // aMax 取值范围应该在 [0, aMax] 之间
```




#### 3.3 快速创建 mask

为了能够方便地创建 mastk 时，需要低位连续的 N 个 1 。例如，生成 0x0f <small>（ 低位上 4 个连续的 1 ）</small>

```java
/**
 * 创建低位上连续的 bits 个 1 。例如，0x0f
 */
public static long continuousOne(int bits) {
    return ~(-1L << bits);
}
```

在获得低位上的连续的 N 个 1 之后，我们通过左移，就能获得想要的 mastk 。

```java
/**
 * @param  bits 连续的 bits 个 1
 * @param shift 从最低位（ 0 ）开始的偏移
 */
public static long createMask(int bits, int shift) {
    return continuousOne(bits) << shift;
}
```