---
alias: 缓存与数据库一致性
---

# 缓存与数据库一致性


## 1. Cache Aside Pattern

标准的方案，facebook 就是使用这种方式。这个方案的中文翻译也叫“**旁路缓存**”。

| 核心概念 | 说明 |
| :- | :- | 
| 失效 | 应用程序先从 cache 取数据，没有得到。|
| 命中 | 应用程序从 cache 中取数据，取到后返回。|
| 更新 | 先把数据存到数据库中，成功后，再让缓存失效。|



### 读流程：

| 步骤 | 说明|
| :-: | :- |
| 1 | 读缓存，命中则直接返回 |
| 2 | 如果没命中，读数据库 |
| 3 | 更新缓存 |


### 写流程：

| 步骤 | 说明|
| :-: | :- |
| 1 | 更新数据库 |
| 2 | 删缓存，使缓存失效 | 


### 补充：

1. 新增操作不需要“动”Redis。
2. 修改操作对 Redis 的操作是**删除**，不是修改。


## 2. 双写并发问题 

Cache Aside Pattern 方案能解决 `双写并发` 问题：

> 双写并发：简而言之，`张三的写操作` 一旦和 `李四的写操作` 交织在一起，就会导致缓存中的数据错误。


| # | 用户 | 操作 | 数据库中的值 | 缓存中的值 |
| :-: | :-   | :-         | :-:      | :-: |
| 1 | 张三-1 | 更新数据库 | `10 -> 20` | 10 |
| 3 | 李四-1 | 更新数据库 | `20 -> 30` | 30 |
| 2 | 李四-2 | 删除缓存   | `30`       | 无 |
| 4 | 张三-2 | 删除缓存   | `30`       | 无 |
| 7 | 最终   | -          | `30`       | 无 |


## 3. 读写并发问题 

Cache Aside Pattern 方案能解决不了全部的 `读写并发` 问题：

> 读写并发：简而言之，`张三的写操作` 一旦和 `李四的读操作` 交织在一起，就会导致缓存中的数据错误。

一部分的 `读写并发` 问题，Cache Aside Pattern 方案能解决。例如：


| # | 用户 | 操作 | 数据库中的值 | 缓存中的值 |
| :-: | :- | :- | :-: | :-: |
| 1 | 李四-1 | 读缓存，没命中     | 10  | 无 |
| 2 | 张三-1 | 更新数据库 | `10 -> 20` | 10 |
| 3 | 张三-2 | 删除缓存   | 10 | 无 |
| 4 | 李四-2 | 读数据库   | 20 | 无 |
| 5 | 李四-3 | 更新缓存，同步数据   | 20 | 20 |
| 6 | 最终   | -          | 20 | 20 |

但是，如果是下面这样的交织时序，Cache Aside Pattern 方案也无能为力：


| # | 用户 | 操作 | 数据库中的值 | 缓存中的值 |
| :-: | :-------- | :------------- | :-:        | :-: |
|  2  | 李四-读-1 | 读缓存，没命中 | 10         | 无 |
|  3  | 李四-读-2 | 读数据库       | 10         | 无 |
|  4  | 张三-写-1 | 更新数据库     | `10 -> 20` | 无 |
|  5  | 张三-写-2 | 删除缓存       | 20         | 无 |
|  6  | 李四-读-3 | 更新缓存       | 20         | 10 |
|  7  | 最终      | -              | 20         | 10 |


## 4. Cache Aside Pattern 方案总结 

这个方案足够简单，容易理解，容易实现。只是面对『**1/3的读写并发问题无能为力**』，不过，实际上出现这种概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

CAP 方案的利远远大于弊，所以，它仍然是“缓存/数据库数据同步”领域中的“第一方案”。


## 5. Cache Aside Pattern 方案的改进 

如果需要改进“CAP 的无法解决一部分的读写并发问题问题，从而导致的缓存中数据错误”的问题，有以下几个思路<small>（当然都要付出一定的代价）</small>：

> [!note] CAP 改进方案一：读操作存缓存时务必要加过期自动删除时间。

> 这也是唯一一个具有实际使用价值的、可能会用得上的方案，而其它方案更倾向于学术上的探讨，大概率是用不上的。

在写操作更新缓存时，务必要加上过期自动删除，这样，如果出现了极端的读写并发数据错误情景，缓存中错误的数据在超时时长到期后会被 Redis 删掉，而此之后的下一次查询，会从数据库中读取到正确的数据写入缓存。

缺点是：延迟多久删除没有一个很好的定论：

- 延迟删除时间太长，数据错误的时间就越长；
- 延迟删除时间太短，会增加查询数据库的次数，进而降低缓存的价值。

> [!note] CAP 改进方案二：借助消息队列，延迟删除

将写操作的『删除 Redis』操作改为异步的延迟删除。例如：更新完数据库，1 秒钟之后再删除缓存。

这种情况下，读写并发造成的数据不一致问题最多也就存在 1 秒。

> 这个改进方案的问题在于：你要延迟多久？延迟的时间短了没有解决读写并发问题；延迟的时间越长不一致隐患就越大。
> 
> 当然，在一致性要求不是那么高的情况下，有 3、5 秒的窗口期数据不一致很正常。

缺点是：

- 和前一个方案的缺点一样，延迟多久删除没有一个很好的定论。
- 它依赖于 RabbitMQ ，增加了系统的风险。

> [!note] CAP 改进方案三：借助消息队列，将删存缓存的工作委托给第三方

- 读数据的人，在发现缓存中没有数据时，不再由他自己来刷新缓存，而是由『别人』来刷新；

- 写数据的人，在更新完数据库之后，不再由他自己来删除缓存，而是由『别人』来删除；

简单来说：『别人』先查后刷，查刷一体 。

分析：『别人』是串行化接收、处理消息，在更新缓存时，他是先读 DB，再写 Cache ，这个过程中是没有『其它的别人』插入的。

方案三的优点在于，它不用像方案一和方案二那样去纠结多久删除合适。

缺点是：除了依赖于 RabbitMQ 之外，还要依赖于“另一个”微服务，进一步增加了系统的风险。

> [!note] CAP 改进方案四：上锁

从根本上解决“并发”问题。

优点：不依赖于 RabbitMQ 或“另一个”微服务，只依赖于 Redis 。

缺点：

- 有性能损耗。在这种小概率的“问题”的情况下，明摆着为了解决这个问题是得不偿失的。
- 不能用本地锁，只能用分布式锁。本地锁解决不了问题。



