---
alias: "鉴权失败后返回 JSON String"
---

## 鉴权失败后返回 JSON String

Spring Security 的认证工作是由 **FilterSecurityInterceptor** 处理的。**FilterSecurityInterceptor** 会抛出 2 种异常：

1. 在用户“该登录而未登录”时，抛出 <mark style="background: #CACFD9A6;">AuthenticationException</mark> 异常；

    默认情况下，抛出 AuthenticationException 异常时，Spring Security 返回 401 错误：未授权<small>（Unauthorized）</small>。

2.  在用户“权限不够”时，抛出 <mark style="background: #CACFD9A6;">AccessDeniedException</mark> 异常。

    默认情况下，抛出 AccessDeniedException 异常时，Spring Security 返回 403 错误：被拒绝<small>（Forbidden）</small>访问

在 Spring Security 配置中可以通过 <mark style="background: #CACFD9A6;">http.exceptionHandling()</mark> 配置方法用来自定义鉴权环节的异常处理。配置风格如下：

```java
http.exceptionHandling()
    .authenticationEntryPoint( … )
    .accessDeniedHandler( … );
```

其中：

- AuthenticationEntryPoint 该类用来统一处理 AuthenticationException 异常；

- AccessDeniedHandler 该类用来统一处理 AccessDeniedException 异常。

### 第 1 步：实现 AuthenticationEntryPoint 接口

```java
@Component
@RequiredArgsConstructor
public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint {

  private final ObjectMapper objectMapper;

  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) 
          throws IOException, ServletException {
      HashMap<String, String> map = new HashMap<>(2);
      map.put("uri", request.getRequestURI());
      map.put("msg", "你是不是没登录？");
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      response.setCharacterEncoding(StandardCharsets.UTF_8.toString());
      response.setContentType(MediaType.APPLICATION_JSON_VALUE);

      String resBody = objectMapper.writeValueAsString(map);
      PrintWriter printWriter = response.getWriter();
      printWriter.print(resBody);
      printWriter.flush();
      printWriter.close();
  }
}
```

### 第 2 步：实现 AccessDeniedHandler 接口

```java
@Component
@RequiredArgsConstructor
public class SimpleAccessDeniedHandler implements AccessDeniedHandler {

  private final ObjectMapper objectMapper;

  @Override
  public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) 
          throws IOException, ServletException {
      HashMap<String, String> map = new HashMap<>(2);
      map.put("uri", request.getRequestURI());
      map.put("msg", "权限不够，喊你爸爸来。");
      response.setStatus(HttpServletResponse.SC_FORBIDDEN);
      response.setCharacterEncoding(StandardCharsets.UTF_8.toString());
      response.setContentType(MediaType.APPLICATION_JSON_VALUE);

      String resBody = objectMapper.writeValueAsString(map);
      PrintWriter printWriter = response.getWriter();
      printWriter.print(resBody);
      printWriter.flush();
      printWriter.close();
  }
}
```


> [!summary] 其它
> - [[202208151955|认证环节的异常处理]] 
> - [[202301061833|捕获异常后的不同]]

### 第 3 步：配置鉴权异常处理

```java
@RequiredArgsConstructor  
@EnableWebSecurity(debug = true)  
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final SimpleAuthenticationEntryPoint simpleAuthenticationEntryPoint;  
    private final SimpleAccessDeniedHandler simpleAccessDeniedHandler;

    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http.exceptionHandling()  
            .authenticationEntryPoint(simpleAuthenticationEntryPoint)  
            .accessDeniedHandler(simpleAccessDeniedHandler);  

        …
    }
}
```

### 第 4 步：验证

略