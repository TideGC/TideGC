---
alias: 硬撤销
tags: 
- git 
- reset
---

## 硬撤销

> 用游戏做类别：读更久远的之前的档，然后这个档之后的存档，统统不要了。这个操作会“删档”。

````ad-success
title: 结论先行
| # | 工作区 | 历史记录| 说明 |
| :- | :- | :- | :- |
| checkout | 变|不变| 既不丢数据，又不丢存档，但可以翻旧账 |
| 软撤销 | 不变|变| 不丢数据，丢存档 |
| 硬撤销 | 变|变| 数据、存档都丢 |
````

现在，我们都知道 git add 和 git commit 的组合是将有变动的 "未提交" 的文件的状态变成 "已提交" 并记录具体有哪些变动，从而形成新的"历史版本"。

在上面的描述中，进行了 2 方面的工作：

1. 改变了相关文件状态，从 “未提交” 变成了 “已提交” 。
2. 将相关文件的变动做了存档，形成了一个新的提交记录<small>（节点）</small>。

硬撤销所做的工作包括：

- 删除了提交记录；
- 删除了文件的改动。

硬<small>（hard）</small>撤销是完全符合我们的常识的。

硬撤到过去的某个存档之后，从那里开始到「现在」所有所发生的一切都会消失，如同从未出现过。

[缺图一张]

---

有一个有意思的操作<small>（虽然没有什么实际价值）</small>：可以用硬撤销来模拟 HEAD 指针的翻旧账。

1. 先创建一个 bak 分支指针指向当前指针所指向的提交记录<small>（以免硬撤销后代码丢失）</small>；

2. 因为创建新指针分支会自动切换到新分支，所以切换回当前分支指针；

3. 使用硬撤销可以控制当前分支指针往后"走"；使用快速合并可以控制当前指针往"前"走。

当然，这个操作有点"无聊"，如果是为了翻旧账，用 HEAD 指针就好了。





